/* automatically generated by rust-bindgen 0.69.1 */

#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
pub mod root {
  #[allow(unused_imports)]
  use self::super::root;
  pub mod std {
    #[allow(unused_imports)]
    use self::super::super::root;
    pub type nullptr_t = u64;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct basic_string {
      pub _address: u8,
    }
    pub type basic_string__Char_alloc_type = u8;
    pub type basic_string__Alloc_traits = u8;
    pub type basic_string_traits_type = u8;
    pub type basic_string_value_type = u8;
    pub type basic_string_allocator_type = u8;
    pub type basic_string_size_type = u8;
    pub type basic_string_difference_type = u8;
    pub type basic_string_reference = u8;
    pub type basic_string_const_reference = u8;
    pub type basic_string_pointer = u8;
    pub type basic_string_const_pointer = u8;
    pub type basic_string_iterator = u8;
    pub type basic_string_const_iterator = u8;
    pub type basic_string_const_reverse_iterator = u8;
    pub type basic_string_reverse_iterator = u8;
    pub type basic_string___const_iterator = u8;
    pub type basic_string___sv_type = u8;
    pub type basic_string__If_sv = u8;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct basic_string___sv_wrapper {
      pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct basic_string__Alloc_hider {
      pub _address: u8,
    }
    pub const basic_string__S_local_capacity: root::std::basic_string__bindgen_ty_1 = 0;
    pub type basic_string__bindgen_ty_1 = i32;
    #[repr(C)]
    #[repr(align(8))]
    #[derive(Copy, Clone)]
    pub union basic_string__bindgen_ty_2 {
      pub _bindgen_opaque_blob: u64,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct pair {
      pub _address: u8,
    }
    pub type pair_first_type = u8;
    pub type pair_second_type = u8;
    pub type pair__PCCP = u8;
    pub type pair__PCCFP = u8;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct pair___zero_as_null_pointer_constant {
      pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct reverse_iterator {
      pub _address: u8,
    }
    pub type reverse_iterator___traits_type = u8;
    pub type reverse_iterator_iterator_type = u8;
    pub type reverse_iterator_pointer = u8;
    pub type reverse_iterator_difference_type = u8;
    pub type reverse_iterator_reference = u8;
    pub mod __detail {
      #[allow(unused_imports)]
      use self::super::super::super::root;
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct allocator {
      pub _address: u8,
    }
    pub type allocator_value_type = u8;
    pub type allocator_size_type = u64;
    pub type allocator_difference_type = u64;
    pub type allocator_pointer = u8;
    pub type allocator_const_pointer = u8;
    pub type allocator_reference = u8;
    pub type allocator_const_reference = u8;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct allocator_rebind {
      pub _address: u8,
    }
    pub type allocator_rebind_other = u8;
    pub type allocator_propagate_on_container_move_assignment = u8;
    pub type allocator_is_always_equal = u8;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct less {
      pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct map {
      pub _address: u8,
    }
    pub type map_key_type = u8;
    pub type map_mapped_type = u8;
    pub type map_value_type = u8;
    pub type map_key_compare = u8;
    pub type map_allocator_type = u8;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct map_value_compare {
      pub _address: u8,
    }
    pub type map__Pair_alloc_type = u8;
    pub type map__Rep_type = u8;
    pub type map__Alloc_traits = u8;
    pub type map_pointer = u8;
    pub type map_const_pointer = u8;
    pub type map_reference = u8;
    pub type map_const_reference = u8;
    pub type map_iterator = u8;
    pub type map_const_iterator = u8;
    pub type map_size_type = u8;
    pub type map_difference_type = u8;
    pub type map_reverse_iterator = u8;
    pub type map_const_reverse_iterator = u8;
    pub type map_node_type = u8;
    pub type map_insert_return_type = u8;
    pub type string = [u64; 4usize];
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct char_traits {
      pub _address: u8,
    }
    pub mod chrono {
      #[allow(unused_imports)]
      use self::super::super::super::root;
    }
    #[repr(C)]
    #[repr(align(4))]
    #[derive(Debug, Copy, Clone)]
    pub struct once_flag {
      pub _bindgen_opaque_blob: u32,
    }
    #[test]
    fn bindgen_test_layout_once_flag() {
      assert_eq!(
        ::std::mem::size_of::<once_flag>(),
        4usize,
        concat!("Size of: ", stringify!(once_flag))
      );
      assert_eq!(
        ::std::mem::align_of::<once_flag>(),
        4usize,
        concat!("Alignment of ", stringify!(once_flag))
      );
    }
    #[repr(C)]
    #[repr(align(1))]
    #[derive(Debug, Copy, Clone)]
    pub struct once_flag__Prepare_execution {
      pub _bindgen_opaque_blob: u8,
    }
    #[test]
    fn bindgen_test_layout_once_flag__Prepare_execution() {
      assert_eq!(
        ::std::mem::size_of::<once_flag__Prepare_execution>(),
        1usize,
        concat!("Size of: ", stringify!(once_flag__Prepare_execution))
      );
      assert_eq!(
        ::std::mem::align_of::<once_flag__Prepare_execution>(),
        1usize,
        concat!("Alignment of ", stringify!(once_flag__Prepare_execution))
      );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct vector {
      pub _address: u8,
    }
    pub type vector__Base = u8;
    pub type vector__Tp_alloc_type = u8;
    pub type vector__Alloc_traits = u8;
    pub type vector_value_type = u8;
    pub type vector_pointer = u8;
    pub type vector_const_pointer = u8;
    pub type vector_reference = u8;
    pub type vector_const_reference = u8;
    pub type vector_iterator = u8;
    pub type vector_const_iterator = u8;
    pub type vector_const_reverse_iterator = u8;
    pub type vector_reverse_iterator = u8;
    pub type vector_size_type = u64;
    pub type vector_difference_type = u64;
    pub type vector_allocator_type = u8;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct vector__Temporary_value {
      pub _address: u8,
    }
    #[repr(C)]
    #[repr(align(1))]
    #[derive(Copy, Clone)]
    pub union vector__Temporary_value__Storage {
      pub _bindgen_opaque_blob: u8,
    }
  }
  pub mod __gnu_cxx {
    #[allow(unused_imports)]
    use self::super::super::root;
  }
  pub mod __pstl {
    #[allow(unused_imports)]
    use self::super::super::root;
    pub mod execution {
      #[allow(unused_imports)]
      use self::super::super::super::root;
    }
  }
  pub mod re2 {
    #[allow(unused_imports)]
    use self::super::super::root;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct StringPiece {
      pub data_: root::re2::StringPiece_const_pointer,
      pub size_: root::re2::StringPiece_size_type,
    }
    pub type StringPiece_traits_type = u8;
    pub type StringPiece_value_type = ::std::os::raw::c_char;
    pub type StringPiece_pointer = *mut ::std::os::raw::c_char;
    pub type StringPiece_const_pointer = *const ::std::os::raw::c_char;
    pub type StringPiece_reference = *mut ::std::os::raw::c_char;
    pub type StringPiece_const_reference = *const ::std::os::raw::c_char;
    pub type StringPiece_const_iterator = *const ::std::os::raw::c_char;
    pub type StringPiece_iterator = root::re2::StringPiece_const_iterator;
    pub type StringPiece_const_reverse_iterator = u64;
    pub type StringPiece_reverse_iterator = root::re2::StringPiece_const_reverse_iterator;
    pub type StringPiece_size_type = usize;
    pub type StringPiece_difference_type = isize;
    extern "C" {
      #[link_name = "\u{1}_ZN3re211StringPiece4nposE"]
      pub static StringPiece_npos: root::re2::StringPiece_size_type;
    }
    #[test]
    fn bindgen_test_layout_StringPiece() {
      const UNINIT: ::std::mem::MaybeUninit<StringPiece> = ::std::mem::MaybeUninit::uninit();
      let ptr = UNINIT.as_ptr();
      assert_eq!(
        ::std::mem::size_of::<StringPiece>(),
        16usize,
        concat!("Size of: ", stringify!(StringPiece))
      );
      assert_eq!(
        ::std::mem::align_of::<StringPiece>(),
        8usize,
        concat!("Alignment of ", stringify!(StringPiece))
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data_) as usize - ptr as usize },
        0usize,
        concat!(
          "Offset of field: ",
          stringify!(StringPiece),
          "::",
          stringify!(data_)
        )
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size_) as usize - ptr as usize },
        8usize,
        concat!(
          "Offset of field: ",
          stringify!(StringPiece),
          "::",
          stringify!(size_)
        )
      );
    }
    extern "C" {
      #[link_name = "\u{1}_ZNK3re211StringPiece4copyEPcmm"]
      pub fn StringPiece_copy(
        this: *const root::re2::StringPiece,
        buf: *mut ::std::os::raw::c_char,
        n: root::re2::StringPiece_size_type,
        pos: root::re2::StringPiece_size_type,
      ) -> root::re2::StringPiece_size_type;
    }
    extern "C" {
      #[link_name = "\u{1}_ZNK3re211StringPiece6substrEmm"]
      pub fn StringPiece_substr(
        this: *const root::re2::StringPiece,
        pos: root::re2::StringPiece_size_type,
        n: root::re2::StringPiece_size_type,
      ) -> root::re2::StringPiece;
    }
    extern "C" {
      #[link_name = "\u{1}_ZNK3re211StringPiece4findERKS0_m"]
      pub fn StringPiece_find(
        this: *const root::re2::StringPiece,
        s: *const root::re2::StringPiece,
        pos: root::re2::StringPiece_size_type,
      ) -> root::re2::StringPiece_size_type;
    }
    extern "C" {
      #[link_name = "\u{1}_ZNK3re211StringPiece4findEcm"]
      pub fn StringPiece_find1(
        this: *const root::re2::StringPiece,
        c: ::std::os::raw::c_char,
        pos: root::re2::StringPiece_size_type,
      ) -> root::re2::StringPiece_size_type;
    }
    extern "C" {
      #[link_name = "\u{1}_ZNK3re211StringPiece5rfindERKS0_m"]
      pub fn StringPiece_rfind(
        this: *const root::re2::StringPiece,
        s: *const root::re2::StringPiece,
        pos: root::re2::StringPiece_size_type,
      ) -> root::re2::StringPiece_size_type;
    }
    extern "C" {
      #[link_name = "\u{1}_ZNK3re211StringPiece5rfindEcm"]
      pub fn StringPiece_rfind1(
        this: *const root::re2::StringPiece,
        c: ::std::os::raw::c_char,
        pos: root::re2::StringPiece_size_type,
      ) -> root::re2::StringPiece_size_type;
    }
    impl StringPiece {
      #[inline]
      pub unsafe fn copy(
        &self,
        buf: *mut ::std::os::raw::c_char,
        n: root::re2::StringPiece_size_type,
        pos: root::re2::StringPiece_size_type,
      ) -> root::re2::StringPiece_size_type {
        StringPiece_copy(self, buf, n, pos)
      }

      #[inline]
      pub unsafe fn substr(
        &self,
        pos: root::re2::StringPiece_size_type,
        n: root::re2::StringPiece_size_type,
      ) -> root::re2::StringPiece {
        StringPiece_substr(self, pos, n)
      }

      #[inline]
      pub unsafe fn find(
        &self,
        s: *const root::re2::StringPiece,
        pos: root::re2::StringPiece_size_type,
      ) -> root::re2::StringPiece_size_type {
        StringPiece_find(self, s, pos)
      }

      #[inline]
      pub unsafe fn find1(
        &self,
        c: ::std::os::raw::c_char,
        pos: root::re2::StringPiece_size_type,
      ) -> root::re2::StringPiece_size_type {
        StringPiece_find1(self, c, pos)
      }

      #[inline]
      pub unsafe fn rfind(
        &self,
        s: *const root::re2::StringPiece,
        pos: root::re2::StringPiece_size_type,
      ) -> root::re2::StringPiece_size_type {
        StringPiece_rfind(self, s, pos)
      }

      #[inline]
      pub unsafe fn rfind1(
        &self,
        c: ::std::os::raw::c_char,
        pos: root::re2::StringPiece_size_type,
      ) -> root::re2::StringPiece_size_type {
        StringPiece_rfind1(self, c, pos)
      }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct Prog {
      _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct Regexp {
      _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct RE2 {
      pub pattern_: root::std::string,
      pub options_: root::re2::RE2_Options,
      pub entire_regexp_: *mut root::re2::Regexp,
      pub error_: *const root::std::string,
      pub error_code_: root::re2::RE2_ErrorCode,
      pub error_arg_: root::std::string,
      pub prefix_: root::std::string,
      pub prefix_foldcase_: bool,
      pub suffix_regexp_: *mut root::re2::Regexp,
      pub prog_: *mut root::re2::Prog,
      pub num_captures_: ::std::os::raw::c_int,
      pub is_one_pass_: bool,
      pub rprog_: *mut root::re2::Prog,
      pub named_groups_: *const u8,
      pub group_names_: *const u8,
      pub rprog_once_: root::std::once_flag,
      pub named_groups_once_: root::std::once_flag,
      pub group_names_once_: root::std::once_flag,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct RE2_Set {
      _unused: [u8; 0],
    }
    pub const RE2_ErrorCode_NoError: root::re2::RE2_ErrorCode = 0;
    pub const RE2_ErrorCode_ErrorInternal: root::re2::RE2_ErrorCode = 1;
    pub const RE2_ErrorCode_ErrorBadEscape: root::re2::RE2_ErrorCode = 2;
    pub const RE2_ErrorCode_ErrorBadCharClass: root::re2::RE2_ErrorCode = 3;
    pub const RE2_ErrorCode_ErrorBadCharRange: root::re2::RE2_ErrorCode = 4;
    pub const RE2_ErrorCode_ErrorMissingBracket: root::re2::RE2_ErrorCode = 5;
    pub const RE2_ErrorCode_ErrorMissingParen: root::re2::RE2_ErrorCode = 6;
    pub const RE2_ErrorCode_ErrorUnexpectedParen: root::re2::RE2_ErrorCode = 7;
    pub const RE2_ErrorCode_ErrorTrailingBackslash: root::re2::RE2_ErrorCode = 8;
    pub const RE2_ErrorCode_ErrorRepeatArgument: root::re2::RE2_ErrorCode = 9;
    pub const RE2_ErrorCode_ErrorRepeatSize: root::re2::RE2_ErrorCode = 10;
    pub const RE2_ErrorCode_ErrorRepeatOp: root::re2::RE2_ErrorCode = 11;
    pub const RE2_ErrorCode_ErrorBadPerlOp: root::re2::RE2_ErrorCode = 12;
    pub const RE2_ErrorCode_ErrorBadUTF8: root::re2::RE2_ErrorCode = 13;
    pub const RE2_ErrorCode_ErrorBadNamedCapture: root::re2::RE2_ErrorCode = 14;
    pub const RE2_ErrorCode_ErrorPatternTooLarge: root::re2::RE2_ErrorCode = 15;
    pub type RE2_ErrorCode = ::std::os::raw::c_uint;
    pub const RE2_CannedOptions_DefaultOptions: root::re2::RE2_CannedOptions = 0;
    pub const RE2_CannedOptions_Latin1: root::re2::RE2_CannedOptions = 1;
    pub const RE2_CannedOptions_POSIX: root::re2::RE2_CannedOptions = 2;
    pub const RE2_CannedOptions_Quiet: root::re2::RE2_CannedOptions = 3;
    pub type RE2_CannedOptions = ::std::os::raw::c_uint;
    pub const RE2_Anchor_UNANCHORED: root::re2::RE2_Anchor = 0;
    pub const RE2_Anchor_ANCHOR_START: root::re2::RE2_Anchor = 1;
    pub const RE2_Anchor_ANCHOR_BOTH: root::re2::RE2_Anchor = 2;
    pub type RE2_Anchor = ::std::os::raw::c_uint;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct RE2_Options {
      pub encoding_: root::re2::RE2_Options_Encoding,
      pub posix_syntax_: bool,
      pub longest_match_: bool,
      pub log_errors_: bool,
      pub max_mem_: i64,
      pub literal_: bool,
      pub never_nl_: bool,
      pub dot_nl_: bool,
      pub never_capture_: bool,
      pub case_sensitive_: bool,
      pub perl_classes_: bool,
      pub word_boundary_: bool,
      pub one_line_: bool,
    }
    pub const RE2_Options_Encoding_EncodingUTF8: root::re2::RE2_Options_Encoding = 1;
    pub const RE2_Options_Encoding_EncodingLatin1: root::re2::RE2_Options_Encoding = 2;
    pub type RE2_Options_Encoding = ::std::os::raw::c_uint;
    pub const RE2_Options_kDefaultMaxMem: ::std::os::raw::c_int = 8388608;
    #[test]
    fn bindgen_test_layout_RE2_Options() {
      const UNINIT: ::std::mem::MaybeUninit<RE2_Options> = ::std::mem::MaybeUninit::uninit();
      let ptr = UNINIT.as_ptr();
      assert_eq!(
        ::std::mem::size_of::<RE2_Options>(),
        24usize,
        concat!("Size of: ", stringify!(RE2_Options))
      );
      assert_eq!(
        ::std::mem::align_of::<RE2_Options>(),
        8usize,
        concat!("Alignment of ", stringify!(RE2_Options))
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).encoding_) as usize - ptr as usize },
        0usize,
        concat!(
          "Offset of field: ",
          stringify!(RE2_Options),
          "::",
          stringify!(encoding_)
        )
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).posix_syntax_) as usize - ptr as usize },
        4usize,
        concat!(
          "Offset of field: ",
          stringify!(RE2_Options),
          "::",
          stringify!(posix_syntax_)
        )
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).longest_match_) as usize - ptr as usize },
        5usize,
        concat!(
          "Offset of field: ",
          stringify!(RE2_Options),
          "::",
          stringify!(longest_match_)
        )
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log_errors_) as usize - ptr as usize },
        6usize,
        concat!(
          "Offset of field: ",
          stringify!(RE2_Options),
          "::",
          stringify!(log_errors_)
        )
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_mem_) as usize - ptr as usize },
        8usize,
        concat!(
          "Offset of field: ",
          stringify!(RE2_Options),
          "::",
          stringify!(max_mem_)
        )
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).literal_) as usize - ptr as usize },
        16usize,
        concat!(
          "Offset of field: ",
          stringify!(RE2_Options),
          "::",
          stringify!(literal_)
        )
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).never_nl_) as usize - ptr as usize },
        17usize,
        concat!(
          "Offset of field: ",
          stringify!(RE2_Options),
          "::",
          stringify!(never_nl_)
        )
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dot_nl_) as usize - ptr as usize },
        18usize,
        concat!(
          "Offset of field: ",
          stringify!(RE2_Options),
          "::",
          stringify!(dot_nl_)
        )
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).never_capture_) as usize - ptr as usize },
        19usize,
        concat!(
          "Offset of field: ",
          stringify!(RE2_Options),
          "::",
          stringify!(never_capture_)
        )
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).case_sensitive_) as usize - ptr as usize },
        20usize,
        concat!(
          "Offset of field: ",
          stringify!(RE2_Options),
          "::",
          stringify!(case_sensitive_)
        )
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).perl_classes_) as usize - ptr as usize },
        21usize,
        concat!(
          "Offset of field: ",
          stringify!(RE2_Options),
          "::",
          stringify!(perl_classes_)
        )
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).word_boundary_) as usize - ptr as usize },
        22usize,
        concat!(
          "Offset of field: ",
          stringify!(RE2_Options),
          "::",
          stringify!(word_boundary_)
        )
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).one_line_) as usize - ptr as usize },
        23usize,
        concat!(
          "Offset of field: ",
          stringify!(RE2_Options),
          "::",
          stringify!(one_line_)
        )
      );
    }
    extern "C" {
      #[link_name = "\u{1}_ZNK3re23RE27Options10ParseFlagsEv"]
      pub fn RE2_Options_ParseFlags(this: *const root::re2::RE2_Options) -> ::std::os::raw::c_int;
    }
    extern "C" {
      #[link_name = "\u{1}_ZN3re23RE27OptionsC1ENS0_13CannedOptionsE"]
      pub fn RE2_Options_Options(
        this: *mut root::re2::RE2_Options,
        arg1: root::re2::RE2_CannedOptions,
      );
    }
    impl RE2_Options {
      #[inline]
      pub unsafe fn ParseFlags(&self) -> ::std::os::raw::c_int { RE2_Options_ParseFlags(self) }

      #[inline]
      pub unsafe fn new(arg1: root::re2::RE2_CannedOptions) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        RE2_Options_Options(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
      }
    }
    #[test]
    fn bindgen_test_layout_RE2() {
      const UNINIT: ::std::mem::MaybeUninit<RE2> = ::std::mem::MaybeUninit::uninit();
      let ptr = UNINIT.as_ptr();
      assert_eq!(
        ::std::mem::size_of::<RE2>(),
        216usize,
        concat!("Size of: ", stringify!(RE2))
      );
      assert_eq!(
        ::std::mem::align_of::<RE2>(),
        8usize,
        concat!("Alignment of ", stringify!(RE2))
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pattern_) as usize - ptr as usize },
        0usize,
        concat!(
          "Offset of field: ",
          stringify!(RE2),
          "::",
          stringify!(pattern_)
        )
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).options_) as usize - ptr as usize },
        32usize,
        concat!(
          "Offset of field: ",
          stringify!(RE2),
          "::",
          stringify!(options_)
        )
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).entire_regexp_) as usize - ptr as usize },
        56usize,
        concat!(
          "Offset of field: ",
          stringify!(RE2),
          "::",
          stringify!(entire_regexp_)
        )
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_) as usize - ptr as usize },
        64usize,
        concat!(
          "Offset of field: ",
          stringify!(RE2),
          "::",
          stringify!(error_)
        )
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_code_) as usize - ptr as usize },
        72usize,
        concat!(
          "Offset of field: ",
          stringify!(RE2),
          "::",
          stringify!(error_code_)
        )
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_arg_) as usize - ptr as usize },
        80usize,
        concat!(
          "Offset of field: ",
          stringify!(RE2),
          "::",
          stringify!(error_arg_)
        )
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prefix_) as usize - ptr as usize },
        112usize,
        concat!(
          "Offset of field: ",
          stringify!(RE2),
          "::",
          stringify!(prefix_)
        )
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prefix_foldcase_) as usize - ptr as usize },
        144usize,
        concat!(
          "Offset of field: ",
          stringify!(RE2),
          "::",
          stringify!(prefix_foldcase_)
        )
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).suffix_regexp_) as usize - ptr as usize },
        152usize,
        concat!(
          "Offset of field: ",
          stringify!(RE2),
          "::",
          stringify!(suffix_regexp_)
        )
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prog_) as usize - ptr as usize },
        160usize,
        concat!(
          "Offset of field: ",
          stringify!(RE2),
          "::",
          stringify!(prog_)
        )
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_captures_) as usize - ptr as usize },
        168usize,
        concat!(
          "Offset of field: ",
          stringify!(RE2),
          "::",
          stringify!(num_captures_)
        )
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_one_pass_) as usize - ptr as usize },
        172usize,
        concat!(
          "Offset of field: ",
          stringify!(RE2),
          "::",
          stringify!(is_one_pass_)
        )
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rprog_) as usize - ptr as usize },
        176usize,
        concat!(
          "Offset of field: ",
          stringify!(RE2),
          "::",
          stringify!(rprog_)
        )
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).named_groups_) as usize - ptr as usize },
        184usize,
        concat!(
          "Offset of field: ",
          stringify!(RE2),
          "::",
          stringify!(named_groups_)
        )
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).group_names_) as usize - ptr as usize },
        192usize,
        concat!(
          "Offset of field: ",
          stringify!(RE2),
          "::",
          stringify!(group_names_)
        )
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rprog_once_) as usize - ptr as usize },
        200usize,
        concat!(
          "Offset of field: ",
          stringify!(RE2),
          "::",
          stringify!(rprog_once_)
        )
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).named_groups_once_) as usize - ptr as usize },
        204usize,
        concat!(
          "Offset of field: ",
          stringify!(RE2),
          "::",
          stringify!(named_groups_once_)
        )
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).group_names_once_) as usize - ptr as usize },
        208usize,
        concat!(
          "Offset of field: ",
          stringify!(RE2),
          "::",
          stringify!(group_names_once_)
        )
      );
    }
    extern "C" {
      #[link_name = "\u{1}_ZNK3re23RE211ProgramSizeEv"]
      pub fn RE2_ProgramSize(this: *const root::re2::RE2) -> ::std::os::raw::c_int;
    }
    extern "C" {
      #[link_name = "\u{1}_ZNK3re23RE218ReverseProgramSizeEv"]
      pub fn RE2_ReverseProgramSize(this: *const root::re2::RE2) -> ::std::os::raw::c_int;
    }
    extern "C" {
      #[link_name = "\u{1}_ZNK3re23RE213ProgramFanoutEPSt6vectorIiSaIiEE"]
      pub fn RE2_ProgramFanout(
        this: *const root::re2::RE2,
        histogram: *mut u8,
      ) -> ::std::os::raw::c_int;
    }
    extern "C" {
      #[link_name = "\u{1}_ZNK3re23RE220ReverseProgramFanoutEPSt6vectorIiSaIiEE"]
      pub fn RE2_ReverseProgramFanout(
        this: *const root::re2::RE2,
        histogram: *mut u8,
      ) -> ::std::os::raw::c_int;
    }
    extern "C" {
      #[doc = " The array-based matching interface"]
      #[link_name = "\u{1}_ZN3re23RE210FullMatchNERKNS_11StringPieceERKS0_PKPKNS0_3ArgEi"]
      pub fn RE2_FullMatchN(
        text: *const root::re2::StringPiece,
        re: *const root::re2::RE2,
        args: *const *const root::re2::RE2_Arg,
        n: ::std::os::raw::c_int,
      ) -> bool;
    }
    extern "C" {
      #[link_name = "\u{1}_ZN3re23RE213PartialMatchNERKNS_11StringPieceERKS0_PKPKNS0_3ArgEi"]
      pub fn RE2_PartialMatchN(
        text: *const root::re2::StringPiece,
        re: *const root::re2::RE2,
        args: *const *const root::re2::RE2_Arg,
        n: ::std::os::raw::c_int,
      ) -> bool;
    }
    extern "C" {
      #[link_name = "\u{1}_ZN3re23RE28ConsumeNEPNS_11StringPieceERKS0_PKPKNS0_3ArgEi"]
      pub fn RE2_ConsumeN(
        input: *mut root::re2::StringPiece,
        re: *const root::re2::RE2,
        args: *const *const root::re2::RE2_Arg,
        n: ::std::os::raw::c_int,
      ) -> bool;
    }
    extern "C" {
      #[link_name = "\u{1}_ZN3re23RE215FindAndConsumeNEPNS_11StringPieceERKS0_PKPKNS0_3ArgEi"]
      pub fn RE2_FindAndConsumeN(
        input: *mut root::re2::StringPiece,
        re: *const root::re2::RE2,
        args: *const *const root::re2::RE2_Arg,
        n: ::std::os::raw::c_int,
      ) -> bool;
    }
    extern "C" {
      #[link_name = "\u{1}_ZN3re23RE27ReplaceEPNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKS0_RKNS_11StringPieceE"]
      pub fn RE2_Replace(
        str_: *mut root::std::string,
        re: *const root::re2::RE2,
        rewrite: *const root::re2::StringPiece,
      ) -> bool;
    }
    extern "C" {
      #[link_name = "\u{1}_ZN3re23RE213GlobalReplaceEPNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKS0_RKNS_11StringPieceE"]
      pub fn RE2_GlobalReplace(
        str_: *mut root::std::string,
        re: *const root::re2::RE2,
        rewrite: *const root::re2::StringPiece,
      ) -> ::std::os::raw::c_int;
    }
    extern "C" {
      #[link_name = "\u{1}_ZN3re23RE27ExtractERKNS_11StringPieceERKS0_S3_PNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
      pub fn RE2_Extract(
        text: *const root::re2::StringPiece,
        re: *const root::re2::RE2,
        rewrite: *const root::re2::StringPiece,
        out: *mut root::std::string,
      ) -> bool;
    }
    extern "C" {
      #[link_name = "\u{1}_ZN3re23RE29QuoteMetaB5cxx11ERKNS_11StringPieceE"]
      pub fn RE2_QuoteMeta(unquoted: *const root::re2::StringPiece) -> root::std::string;
    }
    extern "C" {
      #[link_name = "\u{1}_ZNK3re23RE218PossibleMatchRangeEPNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES7_i"]
      pub fn RE2_PossibleMatchRange(
        this: *const root::re2::RE2,
        min: *mut root::std::string,
        max: *mut root::std::string,
        maxlen: ::std::os::raw::c_int,
      ) -> bool;
    }
    extern "C" {
      #[link_name = "\u{1}_ZNK3re23RE220NamedCapturingGroupsB5cxx11Ev"]
      pub fn RE2_NamedCapturingGroups(this: *const root::re2::RE2) -> *const u8;
    }
    extern "C" {
      #[link_name = "\u{1}_ZNK3re23RE219CapturingGroupNamesB5cxx11Ev"]
      pub fn RE2_CapturingGroupNames(this: *const root::re2::RE2) -> *const u8;
    }
    extern "C" {
      #[link_name = "\u{1}_ZNK3re23RE25MatchERKNS_11StringPieceEmmNS0_6AnchorEPS1_i"]
      pub fn RE2_Match(
        this: *const root::re2::RE2,
        text: *const root::re2::StringPiece,
        startpos: usize,
        endpos: usize,
        re_anchor: root::re2::RE2_Anchor,
        submatch: *mut root::re2::StringPiece,
        nsubmatch: ::std::os::raw::c_int,
      ) -> bool;
    }
    extern "C" {
      #[link_name = "\u{1}_ZNK3re23RE218CheckRewriteStringERKNS_11StringPieceEPNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
      pub fn RE2_CheckRewriteString(
        this: *const root::re2::RE2,
        rewrite: *const root::re2::StringPiece,
        error: *mut root::std::string,
      ) -> bool;
    }
    extern "C" {
      #[link_name = "\u{1}_ZN3re23RE211MaxSubmatchERKNS_11StringPieceE"]
      pub fn RE2_MaxSubmatch(rewrite: *const root::re2::StringPiece) -> ::std::os::raw::c_int;
    }
    extern "C" {
      #[link_name = "\u{1}_ZNK3re23RE27RewriteEPNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKNS_11StringPieceEPS9_i"]
      pub fn RE2_Rewrite(
        this: *const root::re2::RE2,
        out: *mut root::std::string,
        rewrite: *const root::re2::StringPiece,
        vec: *const root::re2::StringPiece,
        veclen: ::std::os::raw::c_int,
      ) -> bool;
    }
    extern "C" {
      #[link_name = "\u{1}_ZN3re23RE2C1EPKc"]
      pub fn RE2_RE2(this: *mut root::re2::RE2, pattern: *const ::std::os::raw::c_char);
    }
    extern "C" {
      #[link_name = "\u{1}_ZN3re23RE2C1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
      pub fn RE2_RE21(this: *mut root::re2::RE2, pattern: *const root::std::string);
    }
    extern "C" {
      #[link_name = "\u{1}_ZN3re23RE2C1ERKNS_11StringPieceE"]
      pub fn RE2_RE22(this: *mut root::re2::RE2, pattern: *const root::re2::StringPiece);
    }
    extern "C" {
      #[link_name = "\u{1}_ZN3re23RE2C1ERKNS_11StringPieceERKNS0_7OptionsE"]
      pub fn RE2_RE23(
        this: *mut root::re2::RE2,
        pattern: *const root::re2::StringPiece,
        options: *const root::re2::RE2_Options,
      );
    }
    extern "C" {
      #[link_name = "\u{1}_ZN3re23RE2D1Ev"]
      pub fn RE2_RE2_destructor(this: *mut root::re2::RE2);
    }
    impl RE2 {
      #[inline]
      pub unsafe fn ProgramSize(&self) -> ::std::os::raw::c_int { RE2_ProgramSize(self) }

      #[inline]
      pub unsafe fn ReverseProgramSize(&self) -> ::std::os::raw::c_int {
        RE2_ReverseProgramSize(self)
      }

      #[inline]
      pub unsafe fn ProgramFanout(&self, histogram: *mut u8) -> ::std::os::raw::c_int {
        RE2_ProgramFanout(self, histogram)
      }

      #[inline]
      pub unsafe fn ReverseProgramFanout(&self, histogram: *mut u8) -> ::std::os::raw::c_int {
        RE2_ReverseProgramFanout(self, histogram)
      }

      #[inline]
      pub unsafe fn FullMatchN(
        text: *const root::re2::StringPiece,
        re: *const root::re2::RE2,
        args: *const *const root::re2::RE2_Arg,
        n: ::std::os::raw::c_int,
      ) -> bool {
        RE2_FullMatchN(text, re, args, n)
      }

      #[inline]
      pub unsafe fn PartialMatchN(
        text: *const root::re2::StringPiece,
        re: *const root::re2::RE2,
        args: *const *const root::re2::RE2_Arg,
        n: ::std::os::raw::c_int,
      ) -> bool {
        RE2_PartialMatchN(text, re, args, n)
      }

      #[inline]
      pub unsafe fn ConsumeN(
        input: *mut root::re2::StringPiece,
        re: *const root::re2::RE2,
        args: *const *const root::re2::RE2_Arg,
        n: ::std::os::raw::c_int,
      ) -> bool {
        RE2_ConsumeN(input, re, args, n)
      }

      #[inline]
      pub unsafe fn FindAndConsumeN(
        input: *mut root::re2::StringPiece,
        re: *const root::re2::RE2,
        args: *const *const root::re2::RE2_Arg,
        n: ::std::os::raw::c_int,
      ) -> bool {
        RE2_FindAndConsumeN(input, re, args, n)
      }

      #[inline]
      pub unsafe fn Replace(
        str_: *mut root::std::string,
        re: *const root::re2::RE2,
        rewrite: *const root::re2::StringPiece,
      ) -> bool {
        RE2_Replace(str_, re, rewrite)
      }

      #[inline]
      pub unsafe fn GlobalReplace(
        str_: *mut root::std::string,
        re: *const root::re2::RE2,
        rewrite: *const root::re2::StringPiece,
      ) -> ::std::os::raw::c_int {
        RE2_GlobalReplace(str_, re, rewrite)
      }

      #[inline]
      pub unsafe fn Extract(
        text: *const root::re2::StringPiece,
        re: *const root::re2::RE2,
        rewrite: *const root::re2::StringPiece,
        out: *mut root::std::string,
      ) -> bool {
        RE2_Extract(text, re, rewrite, out)
      }

      #[inline]
      pub unsafe fn QuoteMeta(unquoted: *const root::re2::StringPiece) -> root::std::string {
        RE2_QuoteMeta(unquoted)
      }

      #[inline]
      pub unsafe fn PossibleMatchRange(
        &self,
        min: *mut root::std::string,
        max: *mut root::std::string,
        maxlen: ::std::os::raw::c_int,
      ) -> bool {
        RE2_PossibleMatchRange(self, min, max, maxlen)
      }

      #[inline]
      pub unsafe fn NamedCapturingGroups(&self) -> *const u8 { RE2_NamedCapturingGroups(self) }

      #[inline]
      pub unsafe fn CapturingGroupNames(&self) -> *const u8 { RE2_CapturingGroupNames(self) }

      #[inline]
      pub unsafe fn Match(
        &self,
        text: *const root::re2::StringPiece,
        startpos: usize,
        endpos: usize,
        re_anchor: root::re2::RE2_Anchor,
        submatch: *mut root::re2::StringPiece,
        nsubmatch: ::std::os::raw::c_int,
      ) -> bool {
        RE2_Match(self, text, startpos, endpos, re_anchor, submatch, nsubmatch)
      }

      #[inline]
      pub unsafe fn CheckRewriteString(
        &self,
        rewrite: *const root::re2::StringPiece,
        error: *mut root::std::string,
      ) -> bool {
        RE2_CheckRewriteString(self, rewrite, error)
      }

      #[inline]
      pub unsafe fn MaxSubmatch(rewrite: *const root::re2::StringPiece) -> ::std::os::raw::c_int {
        RE2_MaxSubmatch(rewrite)
      }

      #[inline]
      pub unsafe fn Rewrite(
        &self,
        out: *mut root::std::string,
        rewrite: *const root::re2::StringPiece,
        vec: *const root::re2::StringPiece,
        veclen: ::std::os::raw::c_int,
      ) -> bool {
        RE2_Rewrite(self, out, rewrite, vec, veclen)
      }

      #[inline]
      pub unsafe fn new(pattern: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        RE2_RE2(__bindgen_tmp.as_mut_ptr(), pattern);
        __bindgen_tmp.assume_init()
      }

      #[inline]
      pub unsafe fn new1(pattern: *const root::std::string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        RE2_RE21(__bindgen_tmp.as_mut_ptr(), pattern);
        __bindgen_tmp.assume_init()
      }

      #[inline]
      pub unsafe fn new2(pattern: *const root::re2::StringPiece) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        RE2_RE22(__bindgen_tmp.as_mut_ptr(), pattern);
        __bindgen_tmp.assume_init()
      }

      #[inline]
      pub unsafe fn new3(
        pattern: *const root::re2::StringPiece,
        options: *const root::re2::RE2_Options,
      ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        RE2_RE23(__bindgen_tmp.as_mut_ptr(), pattern, options);
        __bindgen_tmp.assume_init()
      }

      #[inline]
      pub unsafe fn destruct(&mut self) { RE2_RE2_destructor(self) }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct RE2_Arg {
      pub arg_: *mut ::std::os::raw::c_void,
      pub parser_: root::re2::RE2_Arg_Parser,
    }
    pub type RE2_Arg_CanParse3ary = u8;
    pub type RE2_Arg_CanParse4ary = u8;
    pub type RE2_Arg_CanParseFrom = u8;
    pub type RE2_Arg_Parser = ::std::option::Option<
      unsafe extern "C" fn(
        str_: *const ::std::os::raw::c_char,
        n: usize,
        dest: *mut ::std::os::raw::c_void,
      ) -> bool,
    >;
    #[test]
    fn bindgen_test_layout_RE2_Arg() {
      const UNINIT: ::std::mem::MaybeUninit<RE2_Arg> = ::std::mem::MaybeUninit::uninit();
      let ptr = UNINIT.as_ptr();
      assert_eq!(
        ::std::mem::size_of::<RE2_Arg>(),
        16usize,
        concat!("Size of: ", stringify!(RE2_Arg))
      );
      assert_eq!(
        ::std::mem::align_of::<RE2_Arg>(),
        8usize,
        concat!("Alignment of ", stringify!(RE2_Arg))
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arg_) as usize - ptr as usize },
        0usize,
        concat!(
          "Offset of field: ",
          stringify!(RE2_Arg),
          "::",
          stringify!(arg_)
        )
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parser_) as usize - ptr as usize },
        8usize,
        concat!(
          "Offset of field: ",
          stringify!(RE2_Arg),
          "::",
          stringify!(parser_)
        )
      );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct LazyRE2 {
      pub pattern_: *const ::std::os::raw::c_char,
      pub options_: root::re2::RE2_CannedOptions,
      pub barrier_against_excess_initializers_: root::re2::LazyRE2_NoArg,
      pub ptr_: *mut root::re2::RE2,
      pub once_: root::std::once_flag,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct LazyRE2_NoArg {
      pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_LazyRE2_NoArg() {
      assert_eq!(
        ::std::mem::size_of::<LazyRE2_NoArg>(),
        1usize,
        concat!("Size of: ", stringify!(LazyRE2_NoArg))
      );
      assert_eq!(
        ::std::mem::align_of::<LazyRE2_NoArg>(),
        1usize,
        concat!("Alignment of ", stringify!(LazyRE2_NoArg))
      );
    }
    pub type LazyRE2_element_type = root::re2::RE2;
    #[test]
    fn bindgen_test_layout_LazyRE2() {
      const UNINIT: ::std::mem::MaybeUninit<LazyRE2> = ::std::mem::MaybeUninit::uninit();
      let ptr = UNINIT.as_ptr();
      assert_eq!(
        ::std::mem::size_of::<LazyRE2>(),
        32usize,
        concat!("Size of: ", stringify!(LazyRE2))
      );
      assert_eq!(
        ::std::mem::align_of::<LazyRE2>(),
        8usize,
        concat!("Alignment of ", stringify!(LazyRE2))
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pattern_) as usize - ptr as usize },
        0usize,
        concat!(
          "Offset of field: ",
          stringify!(LazyRE2),
          "::",
          stringify!(pattern_)
        )
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).options_) as usize - ptr as usize },
        8usize,
        concat!(
          "Offset of field: ",
          stringify!(LazyRE2),
          "::",
          stringify!(options_)
        )
      );
      assert_eq!(
        unsafe {
          ::std::ptr::addr_of!((*ptr).barrier_against_excess_initializers_) as usize - ptr as usize
        },
        12usize,
        concat!(
          "Offset of field: ",
          stringify!(LazyRE2),
          "::",
          stringify!(barrier_against_excess_initializers_)
        )
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr_) as usize - ptr as usize },
        16usize,
        concat!(
          "Offset of field: ",
          stringify!(LazyRE2),
          "::",
          stringify!(ptr_)
        )
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).once_) as usize - ptr as usize },
        24usize,
        concat!(
          "Offset of field: ",
          stringify!(LazyRE2),
          "::",
          stringify!(once_)
        )
      );
    }
    pub mod hooks {
      #[allow(unused_imports)]
      use self::super::super::super::root;
    }
  }
}
