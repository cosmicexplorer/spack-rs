/* automatically generated by rust-bindgen 0.69.1 */

#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
pub mod root {
  #[repr(C)]
  #[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
  pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
  }
  impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self { Self { storage } }
  }
  impl<Storage> __BindgenBitfieldUnit<Storage>
  where Storage: AsRef<[u8]>+AsMut<[u8]>
  {
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
      debug_assert!(index / 8 < self.storage.as_ref().len());
      let byte_index = index / 8;
      let byte = self.storage.as_ref()[byte_index];
      let bit_index = if cfg!(target_endian = "big") {
        7 - (index % 8)
      } else {
        index % 8
      };
      let mask = 1 << bit_index;
      byte & mask == mask
    }

    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
      debug_assert!(index / 8 < self.storage.as_ref().len());
      let byte_index = index / 8;
      let byte = &mut self.storage.as_mut()[byte_index];
      let bit_index = if cfg!(target_endian = "big") {
        7 - (index % 8)
      } else {
        index % 8
      };
      let mask = 1 << bit_index;
      if val {
        *byte |= mask;
      } else {
        *byte &= !mask;
      }
    }

    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
      debug_assert!(bit_width <= 64);
      debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
      debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
      let mut val = 0;
      for i in 0..(bit_width as usize) {
        if self.get_bit(i + bit_offset) {
          let index = if cfg!(target_endian = "big") {
            bit_width as usize - 1 - i
          } else {
            i
          };
          val |= 1 << index;
        }
      }
      val
    }

    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
      debug_assert!(bit_width <= 64);
      debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
      debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
      for i in 0..(bit_width as usize) {
        let mask = 1 << i;
        let val_bit_is_set = val & mask == mask;
        let index = if cfg!(target_endian = "big") {
          bit_width as usize - 1 - i
        } else {
          i
        };
        self.set_bit(index + bit_offset, val_bit_is_set);
      }
    }
  }
  #[allow(unused_imports)]
  use self::super::root;
  pub mod std {
    #[allow(unused_imports)]
    use self::super::super::root;
    pub type nullptr_t = u64;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct basic_string {
      pub _address: u8,
    }
    pub type basic_string__Char_alloc_type = u8;
    pub type basic_string__Alloc_traits = u8;
    pub type basic_string_traits_type = u8;
    pub type basic_string_value_type = u8;
    pub type basic_string_allocator_type = u8;
    pub type basic_string_size_type = u8;
    pub type basic_string_difference_type = u8;
    pub type basic_string_reference = u8;
    pub type basic_string_const_reference = u8;
    pub type basic_string_pointer = u8;
    pub type basic_string_const_pointer = u8;
    pub type basic_string_iterator = u8;
    pub type basic_string_const_iterator = u8;
    pub type basic_string_const_reverse_iterator = u8;
    pub type basic_string_reverse_iterator = u8;
    pub type basic_string___const_iterator = u8;
    pub type basic_string___sv_type = u8;
    pub type basic_string__If_sv = u8;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct basic_string___sv_wrapper {
      pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct basic_string__Alloc_hider {
      pub _address: u8,
    }
    pub const basic_string__S_local_capacity: root::std::basic_string__bindgen_ty_1 = 0;
    pub type basic_string__bindgen_ty_1 = i32;
    #[repr(C)]
    #[repr(align(8))]
    #[derive(Copy, Clone)]
    pub union basic_string__bindgen_ty_2 {
      pub _bindgen_opaque_blob: u64,
    }
    pub type false_type = u8;
    pub mod __detail {
      #[allow(unused_imports)]
      use self::super::super::super::root;
    }
    pub mod ranges {
      #[allow(unused_imports)]
      use self::super::super::super::root;
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct pair {
      pub _address: u8,
    }
    pub type pair_first_type = u8;
    pub type pair_second_type = u8;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct allocator {
      pub _address: u8,
    }
    pub type allocator_value_type = u8;
    pub type allocator_size_type = u64;
    pub type allocator_difference_type = u64;
    pub type allocator_propagate_on_container_move_assignment = u8;
    pub type allocator_is_always_equal = u8;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct less {
      pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct map {
      pub _address: u8,
    }
    pub type map_key_type = u8;
    pub type map_mapped_type = u8;
    pub type map_value_type = u8;
    pub type map_key_compare = u8;
    pub type map_allocator_type = u8;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct map_value_compare {
      pub _address: u8,
    }
    pub type map__Pair_alloc_type = u8;
    pub type map__Rep_type = u8;
    pub type map__Alloc_traits = u8;
    pub type map_pointer = u8;
    pub type map_const_pointer = u8;
    pub type map_reference = u8;
    pub type map_const_reference = u8;
    pub type map_iterator = u8;
    pub type map_const_iterator = u8;
    pub type map_size_type = u8;
    pub type map_difference_type = u8;
    pub type map_reverse_iterator = u8;
    pub type map_const_reverse_iterator = u8;
    pub type map_node_type = u8;
    pub type map_insert_return_type = u8;
    pub type string = [u64; 4usize];
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct char_traits {
      pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct basic_string_view {
      pub _address: u8,
    }
    pub type basic_string_view_traits_type = u8;
    pub type basic_string_view_value_type = u8;
    pub type basic_string_view_pointer = u8;
    pub type basic_string_view_const_pointer = u8;
    pub type basic_string_view_reference = u8;
    pub type basic_string_view_const_reference = u8;
    pub type basic_string_view_const_iterator = u8;
    pub type basic_string_view_iterator = u8;
    pub type basic_string_view_const_reverse_iterator = u8;
    pub type basic_string_view_reverse_iterator = u8;
    pub type basic_string_view_size_type = u64;
    pub type basic_string_view_difference_type = u64;
    pub type string_view = [u64; 2usize];
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct vector {
      pub _address: u8,
    }
    pub type vector__Base = u8;
    pub type vector__Tp_alloc_type = u8;
    pub type vector__Alloc_traits = u8;
    pub type vector_value_type = u8;
    pub type vector_pointer = u8;
    pub type vector_const_pointer = u8;
    pub type vector_reference = u8;
    pub type vector_const_reference = u8;
    pub type vector_iterator = u8;
    pub type vector_const_iterator = u8;
    pub type vector_const_reverse_iterator = u8;
    pub type vector_reverse_iterator = u8;
    pub type vector_size_type = u64;
    pub type vector_difference_type = u64;
    pub type vector_allocator_type = u8;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct vector__Temporary_value {
      pub _address: u8,
    }
    #[repr(C)]
    #[repr(align(1))]
    #[derive(Copy, Clone)]
    pub union vector__Temporary_value__Storage {
      pub _bindgen_opaque_blob: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct atomic {
      pub _address: u8,
    }
    pub type atomic_value_type = u8;
  }
  pub mod __gnu_cxx {
    #[allow(unused_imports)]
    use self::super::super::root;
  }
  pub mod __pstl {
    #[allow(unused_imports)]
    use self::super::super::root;
    pub mod execution {
      #[allow(unused_imports)]
      use self::super::super::super::root;
    }
  }
  pub mod absl {
    #[allow(unused_imports)]
    use self::super::super::root;
    pub mod lts_20230125 {
      #[allow(unused_imports)]
      use self::super::super::super::root;
      #[repr(C)]
      #[derive(Debug)]
      pub struct once_flag {
        pub control_: u32,
      }
      #[test]
      fn bindgen_test_layout_once_flag() {
        const UNINIT: ::std::mem::MaybeUninit<once_flag> = ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
          ::std::mem::size_of::<once_flag>(),
          4usize,
          concat!("Size of: ", stringify!(once_flag))
        );
        assert_eq!(
          ::std::mem::align_of::<once_flag>(),
          4usize,
          concat!("Alignment of ", stringify!(once_flag))
        );
        assert_eq!(
          unsafe { ::std::ptr::addr_of!((*ptr).control_) as usize - ptr as usize },
          0usize,
          concat!(
            "Offset of field: ",
            stringify!(once_flag),
            "::",
            stringify!(control_)
          )
        );
      }
      pub type string_view = root::std::string_view;
    }
  }
  pub mod re2 {
    #[allow(unused_imports)]
    use self::super::super::root;
    pub type StringPiece = root::absl::lts_20230125::string_view;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct Prog {
      _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct Regexp {
      _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct StringWrapper {
      pub inner_: root::std::string,
    }
    #[test]
    fn bindgen_test_layout_StringWrapper() {
      const UNINIT: ::std::mem::MaybeUninit<StringWrapper> = ::std::mem::MaybeUninit::uninit();
      let ptr = UNINIT.as_ptr();
      assert_eq!(
        ::std::mem::size_of::<StringWrapper>(),
        32usize,
        concat!("Size of: ", stringify!(StringWrapper))
      );
      assert_eq!(
        ::std::mem::align_of::<StringWrapper>(),
        8usize,
        concat!("Alignment of ", stringify!(StringWrapper))
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inner_) as usize - ptr as usize },
        0usize,
        concat!(
          "Offset of field: ",
          stringify!(StringWrapper),
          "::",
          stringify!(inner_)
        )
      );
    }
    extern "C" {
      #[link_name = "\u{1}_ZNK3re213StringWrapper5emptyEv"]
      pub fn StringWrapper_empty(this: *const root::re2::StringWrapper) -> bool;
    }
    extern "C" {
      #[link_name = "\u{1}_ZNK3re213StringWrapper4sizeEv"]
      pub fn StringWrapper_size(this: *const root::re2::StringWrapper) -> usize;
    }
    extern "C" {
      #[link_name = "\u{1}_ZNK3re213StringWrapper4viewEv"]
      pub fn StringWrapper_view(
        this: *const root::re2::StringWrapper,
      ) -> root::absl::lts_20230125::string_view;
    }
    extern "C" {
      #[link_name = "\u{1}_ZN3re213StringWrapper11get_mutableB5cxx11Ev"]
      pub fn StringWrapper_get_mutable(
        this: *mut root::re2::StringWrapper,
      ) -> *mut root::std::string;
    }
    extern "C" {
      #[link_name = "\u{1}_ZN3re213StringWrapperC1Ev"]
      pub fn StringWrapper_StringWrapper(this: *mut root::re2::StringWrapper);
    }
    extern "C" {
      #[link_name = "\u{1}_ZN3re213StringWrapperC1ESt17basic_string_viewIcSt11char_traitsIcEE"]
      pub fn StringWrapper_StringWrapper1(
        this: *mut root::re2::StringWrapper,
        s: root::absl::lts_20230125::string_view,
      );
    }
    extern "C" {
      #[link_name = "\u{1}_ZN3re213StringWrapperC1EONSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
      pub fn StringWrapper_StringWrapper2(
        this: *mut root::re2::StringWrapper,
        s: *mut root::std::string,
      );
    }
    extern "C" {
      #[link_name = "\u{1}_ZN3re213StringWrapperD1Ev"]
      pub fn StringWrapper_StringWrapper_destructor(this: *mut root::re2::StringWrapper);
    }
    impl StringWrapper {
      #[inline]
      pub unsafe fn empty(&self) -> bool { StringWrapper_empty(self) }

      #[inline]
      pub unsafe fn size(&self) -> usize { StringWrapper_size(self) }

      #[inline]
      pub unsafe fn view(&self) -> root::absl::lts_20230125::string_view {
        StringWrapper_view(self)
      }

      #[inline]
      pub unsafe fn get_mutable(&mut self) -> *mut root::std::string {
        StringWrapper_get_mutable(self)
      }

      #[inline]
      pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        StringWrapper_StringWrapper(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
      }

      #[inline]
      pub unsafe fn new1(s: root::absl::lts_20230125::string_view) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        StringWrapper_StringWrapper1(__bindgen_tmp.as_mut_ptr(), s);
        __bindgen_tmp.assume_init()
      }

      #[inline]
      pub unsafe fn new2(s: *mut root::std::string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        StringWrapper_StringWrapper2(__bindgen_tmp.as_mut_ptr(), s);
        __bindgen_tmp.assume_init()
      }

      #[inline]
      pub unsafe fn destruct(&mut self) { StringWrapper_StringWrapper_destructor(self) }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct NamedGroup {
      pub name: root::absl::lts_20230125::string_view,
      pub index: usize,
    }
    #[test]
    fn bindgen_test_layout_NamedGroup() {
      const UNINIT: ::std::mem::MaybeUninit<NamedGroup> = ::std::mem::MaybeUninit::uninit();
      let ptr = UNINIT.as_ptr();
      assert_eq!(
        ::std::mem::size_of::<NamedGroup>(),
        24usize,
        concat!("Size of: ", stringify!(NamedGroup))
      );
      assert_eq!(
        ::std::mem::align_of::<NamedGroup>(),
        8usize,
        concat!("Alignment of ", stringify!(NamedGroup))
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
          "Offset of field: ",
          stringify!(NamedGroup),
          "::",
          stringify!(name)
        )
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        16usize,
        concat!(
          "Offset of field: ",
          stringify!(NamedGroup),
          "::",
          stringify!(index)
        )
      );
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct GroupNames {
      pub names_: [u64; 3usize],
    }
    #[test]
    fn bindgen_test_layout_GroupNames() {
      const UNINIT: ::std::mem::MaybeUninit<GroupNames> = ::std::mem::MaybeUninit::uninit();
      let ptr = UNINIT.as_ptr();
      assert_eq!(
        ::std::mem::size_of::<GroupNames>(),
        24usize,
        concat!("Size of: ", stringify!(GroupNames))
      );
      assert_eq!(
        ::std::mem::align_of::<GroupNames>(),
        8usize,
        concat!("Alignment of ", stringify!(GroupNames))
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).names_) as usize - ptr as usize },
        0usize,
        concat!(
          "Offset of field: ",
          stringify!(GroupNames),
          "::",
          stringify!(names_)
        )
      );
    }
    extern "C" {
      #[link_name = "\u{1}_ZNK3re210GroupNames4sizeEv"]
      pub fn GroupNames_size(this: *const root::re2::GroupNames) -> usize;
    }
    extern "C" {
      #[link_name = "\u{1}_ZNK3re210GroupNames2atEm"]
      pub fn GroupNames_at(
        this: *const root::re2::GroupNames,
        i: usize,
      ) -> *const root::re2::NamedGroup;
    }
    extern "C" {
      #[link_name = "\u{1}_ZN3re210GroupNamesC1ERKNS_3RE2E"]
      pub fn GroupNames_GroupNames(this: *mut root::re2::GroupNames, r: *const root::re2::RE2);
    }
    extern "C" {
      #[link_name = "\u{1}_ZN3re210GroupNamesD1Ev"]
      pub fn GroupNames_GroupNames_destructor(this: *mut root::re2::GroupNames);
    }
    impl GroupNames {
      #[inline]
      pub unsafe fn size(&self) -> usize { GroupNames_size(self) }

      #[inline]
      pub unsafe fn at(&self, i: usize) -> *const root::re2::NamedGroup { GroupNames_at(self, i) }

      #[inline]
      pub unsafe fn new(r: *const root::re2::RE2) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        GroupNames_GroupNames(__bindgen_tmp.as_mut_ptr(), r);
        __bindgen_tmp.assume_init()
      }

      #[inline]
      pub unsafe fn destruct(&mut self) { GroupNames_GroupNames_destructor(self) }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct RE2 {
      pub pattern_: *const root::std::string,
      pub options_: root::re2::RE2_Options,
      pub entire_regexp_: *mut root::re2::Regexp,
      pub suffix_regexp_: *mut root::re2::Regexp,
      pub error_: *const root::std::string,
      pub error_arg_: *const root::std::string,
      pub num_captures_: ::std::os::raw::c_int,
      pub _bitfield_align_1: [u32; 0],
      pub _bitfield_1: root::__BindgenBitfieldUnit<[u8; 4usize]>,
      pub prefix_: root::std::string,
      pub prog_: *mut root::re2::Prog,
      pub rprog_: *mut root::re2::Prog,
      pub named_groups_: *const [u64; 6usize],
      pub group_names_: *const u8,
      pub rprog_once_: root::absl::lts_20230125::once_flag,
      pub named_groups_once_: root::absl::lts_20230125::once_flag,
      pub group_names_once_: root::absl::lts_20230125::once_flag,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct RE2_Set {
      _unused: [u8; 0],
    }
    pub const RE2_ErrorCode_NoError: root::re2::RE2_ErrorCode = 0;
    pub const RE2_ErrorCode_ErrorInternal: root::re2::RE2_ErrorCode = 1;
    pub const RE2_ErrorCode_ErrorBadEscape: root::re2::RE2_ErrorCode = 2;
    pub const RE2_ErrorCode_ErrorBadCharClass: root::re2::RE2_ErrorCode = 3;
    pub const RE2_ErrorCode_ErrorBadCharRange: root::re2::RE2_ErrorCode = 4;
    pub const RE2_ErrorCode_ErrorMissingBracket: root::re2::RE2_ErrorCode = 5;
    pub const RE2_ErrorCode_ErrorMissingParen: root::re2::RE2_ErrorCode = 6;
    pub const RE2_ErrorCode_ErrorUnexpectedParen: root::re2::RE2_ErrorCode = 7;
    pub const RE2_ErrorCode_ErrorTrailingBackslash: root::re2::RE2_ErrorCode = 8;
    pub const RE2_ErrorCode_ErrorRepeatArgument: root::re2::RE2_ErrorCode = 9;
    pub const RE2_ErrorCode_ErrorRepeatSize: root::re2::RE2_ErrorCode = 10;
    pub const RE2_ErrorCode_ErrorRepeatOp: root::re2::RE2_ErrorCode = 11;
    pub const RE2_ErrorCode_ErrorBadPerlOp: root::re2::RE2_ErrorCode = 12;
    pub const RE2_ErrorCode_ErrorBadUTF8: root::re2::RE2_ErrorCode = 13;
    pub const RE2_ErrorCode_ErrorBadNamedCapture: root::re2::RE2_ErrorCode = 14;
    pub const RE2_ErrorCode_ErrorPatternTooLarge: root::re2::RE2_ErrorCode = 15;
    pub type RE2_ErrorCode = ::std::os::raw::c_uint;
    pub const RE2_CannedOptions_DefaultOptions: root::re2::RE2_CannedOptions = 0;
    pub const RE2_CannedOptions_Latin1: root::re2::RE2_CannedOptions = 1;
    pub const RE2_CannedOptions_POSIX: root::re2::RE2_CannedOptions = 2;
    pub const RE2_CannedOptions_Quiet: root::re2::RE2_CannedOptions = 3;
    pub type RE2_CannedOptions = ::std::os::raw::c_uint;
    pub const RE2_Anchor_UNANCHORED: root::re2::RE2_Anchor = 0;
    pub const RE2_Anchor_ANCHOR_START: root::re2::RE2_Anchor = 1;
    pub const RE2_Anchor_ANCHOR_BOTH: root::re2::RE2_Anchor = 2;
    pub type RE2_Anchor = ::std::os::raw::c_uint;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct RE2_Options {
      pub max_mem_: i64,
      pub encoding_: root::re2::RE2_Options_Encoding,
      pub posix_syntax_: bool,
      pub longest_match_: bool,
      pub log_errors_: bool,
      pub literal_: bool,
      pub never_nl_: bool,
      pub dot_nl_: bool,
      pub never_capture_: bool,
      pub case_sensitive_: bool,
      pub perl_classes_: bool,
      pub word_boundary_: bool,
      pub one_line_: bool,
    }
    pub const RE2_Options_Encoding_EncodingUTF8: root::re2::RE2_Options_Encoding = 1;
    pub const RE2_Options_Encoding_EncodingLatin1: root::re2::RE2_Options_Encoding = 2;
    pub type RE2_Options_Encoding = ::std::os::raw::c_uint;
    pub const RE2_Options_kDefaultMaxMem: ::std::os::raw::c_int = 8388608;
    #[test]
    fn bindgen_test_layout_RE2_Options() {
      const UNINIT: ::std::mem::MaybeUninit<RE2_Options> = ::std::mem::MaybeUninit::uninit();
      let ptr = UNINIT.as_ptr();
      assert_eq!(
        ::std::mem::size_of::<RE2_Options>(),
        24usize,
        concat!("Size of: ", stringify!(RE2_Options))
      );
      assert_eq!(
        ::std::mem::align_of::<RE2_Options>(),
        8usize,
        concat!("Alignment of ", stringify!(RE2_Options))
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_mem_) as usize - ptr as usize },
        0usize,
        concat!(
          "Offset of field: ",
          stringify!(RE2_Options),
          "::",
          stringify!(max_mem_)
        )
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).encoding_) as usize - ptr as usize },
        8usize,
        concat!(
          "Offset of field: ",
          stringify!(RE2_Options),
          "::",
          stringify!(encoding_)
        )
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).posix_syntax_) as usize - ptr as usize },
        12usize,
        concat!(
          "Offset of field: ",
          stringify!(RE2_Options),
          "::",
          stringify!(posix_syntax_)
        )
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).longest_match_) as usize - ptr as usize },
        13usize,
        concat!(
          "Offset of field: ",
          stringify!(RE2_Options),
          "::",
          stringify!(longest_match_)
        )
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log_errors_) as usize - ptr as usize },
        14usize,
        concat!(
          "Offset of field: ",
          stringify!(RE2_Options),
          "::",
          stringify!(log_errors_)
        )
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).literal_) as usize - ptr as usize },
        15usize,
        concat!(
          "Offset of field: ",
          stringify!(RE2_Options),
          "::",
          stringify!(literal_)
        )
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).never_nl_) as usize - ptr as usize },
        16usize,
        concat!(
          "Offset of field: ",
          stringify!(RE2_Options),
          "::",
          stringify!(never_nl_)
        )
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dot_nl_) as usize - ptr as usize },
        17usize,
        concat!(
          "Offset of field: ",
          stringify!(RE2_Options),
          "::",
          stringify!(dot_nl_)
        )
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).never_capture_) as usize - ptr as usize },
        18usize,
        concat!(
          "Offset of field: ",
          stringify!(RE2_Options),
          "::",
          stringify!(never_capture_)
        )
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).case_sensitive_) as usize - ptr as usize },
        19usize,
        concat!(
          "Offset of field: ",
          stringify!(RE2_Options),
          "::",
          stringify!(case_sensitive_)
        )
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).perl_classes_) as usize - ptr as usize },
        20usize,
        concat!(
          "Offset of field: ",
          stringify!(RE2_Options),
          "::",
          stringify!(perl_classes_)
        )
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).word_boundary_) as usize - ptr as usize },
        21usize,
        concat!(
          "Offset of field: ",
          stringify!(RE2_Options),
          "::",
          stringify!(word_boundary_)
        )
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).one_line_) as usize - ptr as usize },
        22usize,
        concat!(
          "Offset of field: ",
          stringify!(RE2_Options),
          "::",
          stringify!(one_line_)
        )
      );
    }
    extern "C" {
      #[link_name = "\u{1}_ZNK3re23RE27Options10ParseFlagsEv"]
      pub fn RE2_Options_ParseFlags(this: *const root::re2::RE2_Options) -> ::std::os::raw::c_int;
    }
    extern "C" {
      #[link_name = "\u{1}_ZN3re23RE27OptionsC1ENS0_13CannedOptionsE"]
      pub fn RE2_Options_Options(
        this: *mut root::re2::RE2_Options,
        arg1: root::re2::RE2_CannedOptions,
      );
    }
    impl RE2_Options {
      #[inline]
      pub unsafe fn ParseFlags(&self) -> ::std::os::raw::c_int { RE2_Options_ParseFlags(self) }

      #[inline]
      pub unsafe fn new(arg1: root::re2::RE2_CannedOptions) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        RE2_Options_Options(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
      }
    }
    #[test]
    fn bindgen_test_layout_RE2() {
      const UNINIT: ::std::mem::MaybeUninit<RE2> = ::std::mem::MaybeUninit::uninit();
      let ptr = UNINIT.as_ptr();
      assert_eq!(
        ::std::mem::size_of::<RE2>(),
        152usize,
        concat!("Size of: ", stringify!(RE2))
      );
      assert_eq!(
        ::std::mem::align_of::<RE2>(),
        8usize,
        concat!("Alignment of ", stringify!(RE2))
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pattern_) as usize - ptr as usize },
        0usize,
        concat!(
          "Offset of field: ",
          stringify!(RE2),
          "::",
          stringify!(pattern_)
        )
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).options_) as usize - ptr as usize },
        8usize,
        concat!(
          "Offset of field: ",
          stringify!(RE2),
          "::",
          stringify!(options_)
        )
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).entire_regexp_) as usize - ptr as usize },
        32usize,
        concat!(
          "Offset of field: ",
          stringify!(RE2),
          "::",
          stringify!(entire_regexp_)
        )
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).suffix_regexp_) as usize - ptr as usize },
        40usize,
        concat!(
          "Offset of field: ",
          stringify!(RE2),
          "::",
          stringify!(suffix_regexp_)
        )
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_) as usize - ptr as usize },
        48usize,
        concat!(
          "Offset of field: ",
          stringify!(RE2),
          "::",
          stringify!(error_)
        )
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_arg_) as usize - ptr as usize },
        56usize,
        concat!(
          "Offset of field: ",
          stringify!(RE2),
          "::",
          stringify!(error_arg_)
        )
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_captures_) as usize - ptr as usize },
        64usize,
        concat!(
          "Offset of field: ",
          stringify!(RE2),
          "::",
          stringify!(num_captures_)
        )
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prefix_) as usize - ptr as usize },
        72usize,
        concat!(
          "Offset of field: ",
          stringify!(RE2),
          "::",
          stringify!(prefix_)
        )
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prog_) as usize - ptr as usize },
        104usize,
        concat!(
          "Offset of field: ",
          stringify!(RE2),
          "::",
          stringify!(prog_)
        )
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rprog_) as usize - ptr as usize },
        112usize,
        concat!(
          "Offset of field: ",
          stringify!(RE2),
          "::",
          stringify!(rprog_)
        )
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).named_groups_) as usize - ptr as usize },
        120usize,
        concat!(
          "Offset of field: ",
          stringify!(RE2),
          "::",
          stringify!(named_groups_)
        )
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).group_names_) as usize - ptr as usize },
        128usize,
        concat!(
          "Offset of field: ",
          stringify!(RE2),
          "::",
          stringify!(group_names_)
        )
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rprog_once_) as usize - ptr as usize },
        136usize,
        concat!(
          "Offset of field: ",
          stringify!(RE2),
          "::",
          stringify!(rprog_once_)
        )
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).named_groups_once_) as usize - ptr as usize },
        140usize,
        concat!(
          "Offset of field: ",
          stringify!(RE2),
          "::",
          stringify!(named_groups_once_)
        )
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).group_names_once_) as usize - ptr as usize },
        144usize,
        concat!(
          "Offset of field: ",
          stringify!(RE2),
          "::",
          stringify!(group_names_once_)
        )
      );
    }
    extern "C" {
      #[link_name = "\u{1}_ZNK3re23RE212pattern_viewEv"]
      pub fn RE2_pattern_view(this: *const root::re2::RE2)
        -> root::absl::lts_20230125::string_view;
    }
    extern "C" {
      #[link_name = "\u{1}_ZNK3re23RE210error_viewEv"]
      pub fn RE2_error_view(this: *const root::re2::RE2) -> root::absl::lts_20230125::string_view;
    }
    extern "C" {
      #[link_name = "\u{1}_ZNK3re23RE214error_arg_viewEv"]
      pub fn RE2_error_arg_view(
        this: *const root::re2::RE2,
      ) -> root::absl::lts_20230125::string_view;
    }
    extern "C" {
      #[link_name = "\u{1}_ZNK3re23RE211ProgramSizeEv"]
      pub fn RE2_ProgramSize(this: *const root::re2::RE2) -> ::std::os::raw::c_int;
    }
    extern "C" {
      #[link_name = "\u{1}_ZNK3re23RE218ReverseProgramSizeEv"]
      pub fn RE2_ReverseProgramSize(this: *const root::re2::RE2) -> ::std::os::raw::c_int;
    }
    extern "C" {
      #[link_name = "\u{1}_ZNK3re23RE213ProgramFanoutEPSt6vectorIiSaIiEE"]
      pub fn RE2_ProgramFanout(
        this: *const root::re2::RE2,
        histogram: *mut u8,
      ) -> ::std::os::raw::c_int;
    }
    extern "C" {
      #[link_name = "\u{1}_ZNK3re23RE220ReverseProgramFanoutEPSt6vectorIiSaIiEE"]
      pub fn RE2_ReverseProgramFanout(
        this: *const root::re2::RE2,
        histogram: *mut u8,
      ) -> ::std::os::raw::c_int;
    }
    extern "C" {
      #[doc = " The array-based matching interface"]
      #[link_name = "\u{1}_ZN3re23RE210FullMatchNESt17basic_string_viewIcSt11char_traitsIcEERKS0_PKPKNS0_3ArgEi"]
      pub fn RE2_FullMatchN(
        text: root::absl::lts_20230125::string_view,
        re: *const root::re2::RE2,
        args: *const *const root::re2::RE2_Arg,
        n: ::std::os::raw::c_int,
      ) -> bool;
    }
    extern "C" {
      #[link_name = "\u{1}_ZN3re23RE213PartialMatchNESt17basic_string_viewIcSt11char_traitsIcEERKS0_PKPKNS0_3ArgEi"]
      pub fn RE2_PartialMatchN(
        text: root::absl::lts_20230125::string_view,
        re: *const root::re2::RE2,
        args: *const *const root::re2::RE2_Arg,
        n: ::std::os::raw::c_int,
      ) -> bool;
    }
    extern "C" {
      #[link_name = "\u{1}_ZN3re23RE28ConsumeNEPSt17basic_string_viewIcSt11char_traitsIcEERKS0_PKPKNS0_3ArgEi"]
      pub fn RE2_ConsumeN(
        input: *mut root::absl::lts_20230125::string_view,
        re: *const root::re2::RE2,
        args: *const *const root::re2::RE2_Arg,
        n: ::std::os::raw::c_int,
      ) -> bool;
    }
    extern "C" {
      #[link_name = "\u{1}_ZN3re23RE215FindAndConsumeNEPSt17basic_string_viewIcSt11char_traitsIcEERKS0_PKPKNS0_3ArgEi"]
      pub fn RE2_FindAndConsumeN(
        input: *mut root::absl::lts_20230125::string_view,
        re: *const root::re2::RE2,
        args: *const *const root::re2::RE2_Arg,
        n: ::std::os::raw::c_int,
      ) -> bool;
    }
    extern "C" {
      #[link_name = "\u{1}_ZN3re23RE27ReplaceEPNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKS0_St17basic_string_viewIcS4_E"]
      pub fn RE2_Replace(
        str_: *mut root::std::string,
        re: *const root::re2::RE2,
        rewrite: root::absl::lts_20230125::string_view,
      ) -> bool;
    }
    extern "C" {
      #[link_name = "\u{1}_ZN3re23RE213GlobalReplaceEPNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKS0_St17basic_string_viewIcS4_E"]
      pub fn RE2_GlobalReplace(
        str_: *mut root::std::string,
        re: *const root::re2::RE2,
        rewrite: root::absl::lts_20230125::string_view,
      ) -> ::std::os::raw::c_int;
    }
    extern "C" {
      #[link_name = "\u{1}_ZN3re23RE27ExtractESt17basic_string_viewIcSt11char_traitsIcEERKS0_S4_PNSt7__cxx1112basic_stringIcS3_SaIcEEE"]
      pub fn RE2_Extract(
        text: root::absl::lts_20230125::string_view,
        re: *const root::re2::RE2,
        rewrite: root::absl::lts_20230125::string_view,
        out: *mut root::std::string,
      ) -> bool;
    }
    extern "C" {
      #[link_name = "\u{1}_ZN3re23RE29QuoteMetaB5cxx11ESt17basic_string_viewIcSt11char_traitsIcEE"]
      pub fn RE2_QuoteMeta(unquoted: root::absl::lts_20230125::string_view) -> root::std::string;
    }
    extern "C" {
      #[link_name = "\u{1}_ZNK3re23RE218PossibleMatchRangeEPNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES7_i"]
      pub fn RE2_PossibleMatchRange(
        this: *const root::re2::RE2,
        min: *mut root::std::string,
        max: *mut root::std::string,
        maxlen: ::std::os::raw::c_int,
      ) -> bool;
    }
    extern "C" {
      #[link_name = "\u{1}_ZNK3re23RE220NamedCapturingGroupsB5cxx11Ev"]
      pub fn RE2_NamedCapturingGroups(this: *const root::re2::RE2) -> *const [u64; 6usize];
    }
    extern "C" {
      #[link_name = "\u{1}_ZNK3re23RE219CapturingGroupNamesB5cxx11Ev"]
      pub fn RE2_CapturingGroupNames(this: *const root::re2::RE2) -> *const u8;
    }
    extern "C" {
      #[link_name = "\u{1}_ZNK3re23RE25MatchESt17basic_string_viewIcSt11char_traitsIcEEmmNS0_6AnchorEPS4_i"]
      pub fn RE2_Match(
        this: *const root::re2::RE2,
        text: root::absl::lts_20230125::string_view,
        startpos: usize,
        endpos: usize,
        re_anchor: root::re2::RE2_Anchor,
        submatch: *mut root::absl::lts_20230125::string_view,
        nsubmatch: ::std::os::raw::c_int,
      ) -> bool;
    }
    extern "C" {
      #[link_name = "\u{1}_ZNK3re23RE218CheckRewriteStringESt17basic_string_viewIcSt11char_traitsIcEEPNSt7__cxx1112basic_stringIcS3_SaIcEEE"]
      pub fn RE2_CheckRewriteString(
        this: *const root::re2::RE2,
        rewrite: root::absl::lts_20230125::string_view,
        error: *mut root::std::string,
      ) -> bool;
    }
    extern "C" {
      #[link_name = "\u{1}_ZN3re23RE211MaxSubmatchESt17basic_string_viewIcSt11char_traitsIcEE"]
      pub fn RE2_MaxSubmatch(
        rewrite: root::absl::lts_20230125::string_view,
      ) -> ::std::os::raw::c_int;
    }
    extern "C" {
      #[link_name = "\u{1}_ZNK3re23RE27RewriteEPNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt17basic_string_viewIcS4_EPKS9_i"]
      pub fn RE2_Rewrite(
        this: *const root::re2::RE2,
        out: *mut root::std::string,
        rewrite: root::absl::lts_20230125::string_view,
        vec: *const root::absl::lts_20230125::string_view,
        veclen: ::std::os::raw::c_int,
      ) -> bool;
    }
    extern "C" {
      #[link_name = "\u{1}_ZN3re23RE245FUZZING_ONLY_set_maximum_global_replace_countEi"]
      pub fn RE2_FUZZING_ONLY_set_maximum_global_replace_count(i: ::std::os::raw::c_int);
    }
    extern "C" {
      #[link_name = "\u{1}_ZN3re23RE2C1EPKc"]
      pub fn RE2_RE2(this: *mut root::re2::RE2, pattern: *const ::std::os::raw::c_char);
    }
    extern "C" {
      #[link_name = "\u{1}_ZN3re23RE2C1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
      pub fn RE2_RE21(this: *mut root::re2::RE2, pattern: *const root::std::string);
    }
    extern "C" {
      #[link_name = "\u{1}_ZN3re23RE2C1ESt17basic_string_viewIcSt11char_traitsIcEE"]
      pub fn RE2_RE22(this: *mut root::re2::RE2, pattern: root::absl::lts_20230125::string_view);
    }
    extern "C" {
      #[link_name = "\u{1}_ZN3re23RE2C1ESt17basic_string_viewIcSt11char_traitsIcEERKNS0_7OptionsE"]
      pub fn RE2_RE23(
        this: *mut root::re2::RE2,
        pattern: root::absl::lts_20230125::string_view,
        options: *const root::re2::RE2_Options,
      );
    }
    extern "C" {
      #[link_name = "\u{1}_ZN3re23RE2D1Ev"]
      pub fn RE2_RE2_destructor(this: *mut root::re2::RE2);
    }
    impl RE2 {
      #[inline]
      pub fn error_code_(&self) -> root::re2::RE2_ErrorCode {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 29u8) as u32) }
      }

      #[inline]
      pub fn set_error_code_(&mut self, val: root::re2::RE2_ErrorCode) {
        unsafe {
          let val: u32 = ::std::mem::transmute(val);
          self._bitfield_1.set(0usize, 29u8, val as u64)
        }
      }

      #[inline]
      pub fn longest_match_(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u8) }
      }

      #[inline]
      pub fn set_longest_match_(&mut self, val: bool) {
        unsafe {
          let val: u8 = ::std::mem::transmute(val);
          self._bitfield_1.set(29usize, 1u8, val as u64)
        }
      }

      #[inline]
      pub fn is_one_pass_(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u8) }
      }

      #[inline]
      pub fn set_is_one_pass_(&mut self, val: bool) {
        unsafe {
          let val: u8 = ::std::mem::transmute(val);
          self._bitfield_1.set(30usize, 1u8, val as u64)
        }
      }

      #[inline]
      pub fn prefix_foldcase_(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u8) }
      }

      #[inline]
      pub fn set_prefix_foldcase_(&mut self, val: bool) {
        unsafe {
          let val: u8 = ::std::mem::transmute(val);
          self._bitfield_1.set(31usize, 1u8, val as u64)
        }
      }

      #[inline]
      pub fn new_bitfield_1(
        error_code_: root::re2::RE2_ErrorCode,
        longest_match_: bool,
        is_one_pass_: bool,
        prefix_foldcase_: bool,
      ) -> root::__BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: root::__BindgenBitfieldUnit<[u8; 4usize]> =
          Default::default();
        __bindgen_bitfield_unit.set(0usize, 29u8, {
          let error_code_: u32 = unsafe { ::std::mem::transmute(error_code_) };
          error_code_ as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
          let longest_match_: u8 = unsafe { ::std::mem::transmute(longest_match_) };
          longest_match_ as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
          let is_one_pass_: u8 = unsafe { ::std::mem::transmute(is_one_pass_) };
          is_one_pass_ as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
          let prefix_foldcase_: u8 = unsafe { ::std::mem::transmute(prefix_foldcase_) };
          prefix_foldcase_ as u64
        });
        __bindgen_bitfield_unit
      }

      #[inline]
      pub unsafe fn pattern_view(&self) -> root::absl::lts_20230125::string_view {
        RE2_pattern_view(self)
      }

      #[inline]
      pub unsafe fn error_view(&self) -> root::absl::lts_20230125::string_view {
        RE2_error_view(self)
      }

      #[inline]
      pub unsafe fn error_arg_view(&self) -> root::absl::lts_20230125::string_view {
        RE2_error_arg_view(self)
      }

      #[inline]
      pub unsafe fn ProgramSize(&self) -> ::std::os::raw::c_int { RE2_ProgramSize(self) }

      #[inline]
      pub unsafe fn ReverseProgramSize(&self) -> ::std::os::raw::c_int {
        RE2_ReverseProgramSize(self)
      }

      #[inline]
      pub unsafe fn ProgramFanout(&self, histogram: *mut u8) -> ::std::os::raw::c_int {
        RE2_ProgramFanout(self, histogram)
      }

      #[inline]
      pub unsafe fn ReverseProgramFanout(&self, histogram: *mut u8) -> ::std::os::raw::c_int {
        RE2_ReverseProgramFanout(self, histogram)
      }

      #[inline]
      pub unsafe fn FullMatchN(
        text: root::absl::lts_20230125::string_view,
        re: *const root::re2::RE2,
        args: *const *const root::re2::RE2_Arg,
        n: ::std::os::raw::c_int,
      ) -> bool {
        RE2_FullMatchN(text, re, args, n)
      }

      #[inline]
      pub unsafe fn PartialMatchN(
        text: root::absl::lts_20230125::string_view,
        re: *const root::re2::RE2,
        args: *const *const root::re2::RE2_Arg,
        n: ::std::os::raw::c_int,
      ) -> bool {
        RE2_PartialMatchN(text, re, args, n)
      }

      #[inline]
      pub unsafe fn ConsumeN(
        input: *mut root::absl::lts_20230125::string_view,
        re: *const root::re2::RE2,
        args: *const *const root::re2::RE2_Arg,
        n: ::std::os::raw::c_int,
      ) -> bool {
        RE2_ConsumeN(input, re, args, n)
      }

      #[inline]
      pub unsafe fn FindAndConsumeN(
        input: *mut root::absl::lts_20230125::string_view,
        re: *const root::re2::RE2,
        args: *const *const root::re2::RE2_Arg,
        n: ::std::os::raw::c_int,
      ) -> bool {
        RE2_FindAndConsumeN(input, re, args, n)
      }

      #[inline]
      pub unsafe fn Replace(
        str_: *mut root::std::string,
        re: *const root::re2::RE2,
        rewrite: root::absl::lts_20230125::string_view,
      ) -> bool {
        RE2_Replace(str_, re, rewrite)
      }

      #[inline]
      pub unsafe fn GlobalReplace(
        str_: *mut root::std::string,
        re: *const root::re2::RE2,
        rewrite: root::absl::lts_20230125::string_view,
      ) -> ::std::os::raw::c_int {
        RE2_GlobalReplace(str_, re, rewrite)
      }

      #[inline]
      pub unsafe fn Extract(
        text: root::absl::lts_20230125::string_view,
        re: *const root::re2::RE2,
        rewrite: root::absl::lts_20230125::string_view,
        out: *mut root::std::string,
      ) -> bool {
        RE2_Extract(text, re, rewrite, out)
      }

      #[inline]
      pub unsafe fn QuoteMeta(
        unquoted: root::absl::lts_20230125::string_view,
      ) -> root::std::string {
        RE2_QuoteMeta(unquoted)
      }

      #[inline]
      pub unsafe fn PossibleMatchRange(
        &self,
        min: *mut root::std::string,
        max: *mut root::std::string,
        maxlen: ::std::os::raw::c_int,
      ) -> bool {
        RE2_PossibleMatchRange(self, min, max, maxlen)
      }

      #[inline]
      pub unsafe fn NamedCapturingGroups(&self) -> *const [u64; 6usize] {
        RE2_NamedCapturingGroups(self)
      }

      #[inline]
      pub unsafe fn CapturingGroupNames(&self) -> *const u8 { RE2_CapturingGroupNames(self) }

      #[inline]
      pub unsafe fn Match(
        &self,
        text: root::absl::lts_20230125::string_view,
        startpos: usize,
        endpos: usize,
        re_anchor: root::re2::RE2_Anchor,
        submatch: *mut root::absl::lts_20230125::string_view,
        nsubmatch: ::std::os::raw::c_int,
      ) -> bool {
        RE2_Match(self, text, startpos, endpos, re_anchor, submatch, nsubmatch)
      }

      #[inline]
      pub unsafe fn CheckRewriteString(
        &self,
        rewrite: root::absl::lts_20230125::string_view,
        error: *mut root::std::string,
      ) -> bool {
        RE2_CheckRewriteString(self, rewrite, error)
      }

      #[inline]
      pub unsafe fn MaxSubmatch(
        rewrite: root::absl::lts_20230125::string_view,
      ) -> ::std::os::raw::c_int {
        RE2_MaxSubmatch(rewrite)
      }

      #[inline]
      pub unsafe fn Rewrite(
        &self,
        out: *mut root::std::string,
        rewrite: root::absl::lts_20230125::string_view,
        vec: *const root::absl::lts_20230125::string_view,
        veclen: ::std::os::raw::c_int,
      ) -> bool {
        RE2_Rewrite(self, out, rewrite, vec, veclen)
      }

      #[inline]
      pub unsafe fn FUZZING_ONLY_set_maximum_global_replace_count(i: ::std::os::raw::c_int) {
        RE2_FUZZING_ONLY_set_maximum_global_replace_count(i)
      }

      #[inline]
      pub unsafe fn new(pattern: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        RE2_RE2(__bindgen_tmp.as_mut_ptr(), pattern);
        __bindgen_tmp.assume_init()
      }

      #[inline]
      pub unsafe fn new1(pattern: *const root::std::string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        RE2_RE21(__bindgen_tmp.as_mut_ptr(), pattern);
        __bindgen_tmp.assume_init()
      }

      #[inline]
      pub unsafe fn new2(pattern: root::absl::lts_20230125::string_view) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        RE2_RE22(__bindgen_tmp.as_mut_ptr(), pattern);
        __bindgen_tmp.assume_init()
      }

      #[inline]
      pub unsafe fn new3(
        pattern: root::absl::lts_20230125::string_view,
        options: *const root::re2::RE2_Options,
      ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        RE2_RE23(__bindgen_tmp.as_mut_ptr(), pattern, options);
        __bindgen_tmp.assume_init()
      }

      #[inline]
      pub unsafe fn destruct(&mut self) { RE2_RE2_destructor(self) }
    }
    pub mod re2_internal {
      #[allow(unused_imports)]
      use self::super::super::super::root;
      #[repr(C)]
      #[derive(Debug, Copy, Clone)]
      pub struct Parse3ary {
        pub _base: root::std::false_type,
      }
      #[test]
      fn __bindgen_test_layout_Parse3ary_open0_void_close0_instantiation() {
        assert_eq!(
          ::std::mem::size_of::<root::re2::re2_internal::Parse3ary>(),
          1usize,
          concat!(
            "Size of template specialization: ",
            stringify!(root::re2::re2_internal::Parse3ary)
          )
        );
        assert_eq!(
          ::std::mem::align_of::<root::re2::re2_internal::Parse3ary>(),
          1usize,
          concat!(
            "Alignment of template specialization: ",
            stringify!(root::re2::re2_internal::Parse3ary)
          )
        );
      }
      #[test]
      fn __bindgen_test_layout_Parse3ary_open0_basic_string_open1_char_char_traits_open2_char_close2_allocator_open2_char_close2_close1_close0_instantiation(
      ) {
        assert_eq!(
          ::std::mem::size_of::<root::re2::re2_internal::Parse3ary>(),
          1usize,
          concat!(
            "Size of template specialization: ",
            stringify!(root::re2::re2_internal::Parse3ary)
          )
        );
        assert_eq!(
          ::std::mem::align_of::<root::re2::re2_internal::Parse3ary>(),
          1usize,
          concat!(
            "Alignment of template specialization: ",
            stringify!(root::re2::re2_internal::Parse3ary)
          )
        );
      }
      #[test]
      fn __bindgen_test_layout_Parse3ary_open0_basic_string_view_open1_char_char_traits_open2_char_close2_close1_close0_instantiation(
      ) {
        assert_eq!(
          ::std::mem::size_of::<root::re2::re2_internal::Parse3ary>(),
          1usize,
          concat!(
            "Size of template specialization: ",
            stringify!(root::re2::re2_internal::Parse3ary)
          )
        );
        assert_eq!(
          ::std::mem::align_of::<root::re2::re2_internal::Parse3ary>(),
          1usize,
          concat!(
            "Alignment of template specialization: ",
            stringify!(root::re2::re2_internal::Parse3ary)
          )
        );
      }
      #[test]
      fn __bindgen_test_layout_Parse3ary_open0_char_close0_instantiation() {
        assert_eq!(
          ::std::mem::size_of::<root::re2::re2_internal::Parse3ary>(),
          1usize,
          concat!(
            "Size of template specialization: ",
            stringify!(root::re2::re2_internal::Parse3ary)
          )
        );
        assert_eq!(
          ::std::mem::align_of::<root::re2::re2_internal::Parse3ary>(),
          1usize,
          concat!(
            "Alignment of template specialization: ",
            stringify!(root::re2::re2_internal::Parse3ary)
          )
        );
      }
      #[test]
      fn __bindgen_test_layout_Parse3ary_open0_signed_char_close0_instantiation() {
        assert_eq!(
          ::std::mem::size_of::<root::re2::re2_internal::Parse3ary>(),
          1usize,
          concat!(
            "Size of template specialization: ",
            stringify!(root::re2::re2_internal::Parse3ary)
          )
        );
        assert_eq!(
          ::std::mem::align_of::<root::re2::re2_internal::Parse3ary>(),
          1usize,
          concat!(
            "Alignment of template specialization: ",
            stringify!(root::re2::re2_internal::Parse3ary)
          )
        );
      }
      #[test]
      fn __bindgen_test_layout_Parse3ary_open0_unsigned_char_close0_instantiation() {
        assert_eq!(
          ::std::mem::size_of::<root::re2::re2_internal::Parse3ary>(),
          1usize,
          concat!(
            "Size of template specialization: ",
            stringify!(root::re2::re2_internal::Parse3ary)
          )
        );
        assert_eq!(
          ::std::mem::align_of::<root::re2::re2_internal::Parse3ary>(),
          1usize,
          concat!(
            "Alignment of template specialization: ",
            stringify!(root::re2::re2_internal::Parse3ary)
          )
        );
      }
      #[test]
      fn __bindgen_test_layout_Parse3ary_open0_float_close0_instantiation() {
        assert_eq!(
          ::std::mem::size_of::<root::re2::re2_internal::Parse3ary>(),
          1usize,
          concat!(
            "Size of template specialization: ",
            stringify!(root::re2::re2_internal::Parse3ary)
          )
        );
        assert_eq!(
          ::std::mem::align_of::<root::re2::re2_internal::Parse3ary>(),
          1usize,
          concat!(
            "Alignment of template specialization: ",
            stringify!(root::re2::re2_internal::Parse3ary)
          )
        );
      }
      #[test]
      fn __bindgen_test_layout_Parse3ary_open0_double_close0_instantiation() {
        assert_eq!(
          ::std::mem::size_of::<root::re2::re2_internal::Parse3ary>(),
          1usize,
          concat!(
            "Size of template specialization: ",
            stringify!(root::re2::re2_internal::Parse3ary)
          )
        );
        assert_eq!(
          ::std::mem::align_of::<root::re2::re2_internal::Parse3ary>(),
          1usize,
          concat!(
            "Alignment of template specialization: ",
            stringify!(root::re2::re2_internal::Parse3ary)
          )
        );
      }
      #[repr(C)]
      #[derive(Debug, Copy, Clone)]
      pub struct Parse4ary {
        pub _base: root::std::false_type,
      }
      #[test]
      fn __bindgen_test_layout_Parse4ary_open0_long_close0_instantiation() {
        assert_eq!(
          ::std::mem::size_of::<root::re2::re2_internal::Parse4ary>(),
          1usize,
          concat!(
            "Size of template specialization: ",
            stringify!(root::re2::re2_internal::Parse4ary)
          )
        );
        assert_eq!(
          ::std::mem::align_of::<root::re2::re2_internal::Parse4ary>(),
          1usize,
          concat!(
            "Alignment of template specialization: ",
            stringify!(root::re2::re2_internal::Parse4ary)
          )
        );
      }
      #[test]
      fn __bindgen_test_layout_Parse4ary_open0_unsigned_long_close0_instantiation() {
        assert_eq!(
          ::std::mem::size_of::<root::re2::re2_internal::Parse4ary>(),
          1usize,
          concat!(
            "Size of template specialization: ",
            stringify!(root::re2::re2_internal::Parse4ary)
          )
        );
        assert_eq!(
          ::std::mem::align_of::<root::re2::re2_internal::Parse4ary>(),
          1usize,
          concat!(
            "Alignment of template specialization: ",
            stringify!(root::re2::re2_internal::Parse4ary)
          )
        );
      }
      #[test]
      fn __bindgen_test_layout_Parse4ary_open0_short_close0_instantiation() {
        assert_eq!(
          ::std::mem::size_of::<root::re2::re2_internal::Parse4ary>(),
          1usize,
          concat!(
            "Size of template specialization: ",
            stringify!(root::re2::re2_internal::Parse4ary)
          )
        );
        assert_eq!(
          ::std::mem::align_of::<root::re2::re2_internal::Parse4ary>(),
          1usize,
          concat!(
            "Alignment of template specialization: ",
            stringify!(root::re2::re2_internal::Parse4ary)
          )
        );
      }
      #[test]
      fn __bindgen_test_layout_Parse4ary_open0_unsigned_short_close0_instantiation() {
        assert_eq!(
          ::std::mem::size_of::<root::re2::re2_internal::Parse4ary>(),
          1usize,
          concat!(
            "Size of template specialization: ",
            stringify!(root::re2::re2_internal::Parse4ary)
          )
        );
        assert_eq!(
          ::std::mem::align_of::<root::re2::re2_internal::Parse4ary>(),
          1usize,
          concat!(
            "Alignment of template specialization: ",
            stringify!(root::re2::re2_internal::Parse4ary)
          )
        );
      }
      #[test]
      fn __bindgen_test_layout_Parse4ary_open0_int_close0_instantiation() {
        assert_eq!(
          ::std::mem::size_of::<root::re2::re2_internal::Parse4ary>(),
          1usize,
          concat!(
            "Size of template specialization: ",
            stringify!(root::re2::re2_internal::Parse4ary)
          )
        );
        assert_eq!(
          ::std::mem::align_of::<root::re2::re2_internal::Parse4ary>(),
          1usize,
          concat!(
            "Alignment of template specialization: ",
            stringify!(root::re2::re2_internal::Parse4ary)
          )
        );
      }
      #[test]
      fn __bindgen_test_layout_Parse4ary_open0_unsigned_int_close0_instantiation() {
        assert_eq!(
          ::std::mem::size_of::<root::re2::re2_internal::Parse4ary>(),
          1usize,
          concat!(
            "Size of template specialization: ",
            stringify!(root::re2::re2_internal::Parse4ary)
          )
        );
        assert_eq!(
          ::std::mem::align_of::<root::re2::re2_internal::Parse4ary>(),
          1usize,
          concat!(
            "Alignment of template specialization: ",
            stringify!(root::re2::re2_internal::Parse4ary)
          )
        );
      }
      #[test]
      fn __bindgen_test_layout_Parse4ary_open0_long_long_close0_instantiation() {
        assert_eq!(
          ::std::mem::size_of::<root::re2::re2_internal::Parse4ary>(),
          1usize,
          concat!(
            "Size of template specialization: ",
            stringify!(root::re2::re2_internal::Parse4ary)
          )
        );
        assert_eq!(
          ::std::mem::align_of::<root::re2::re2_internal::Parse4ary>(),
          1usize,
          concat!(
            "Alignment of template specialization: ",
            stringify!(root::re2::re2_internal::Parse4ary)
          )
        );
      }
      #[test]
      fn __bindgen_test_layout_Parse4ary_open0_unsigned_long_long_close0_instantiation() {
        assert_eq!(
          ::std::mem::size_of::<root::re2::re2_internal::Parse4ary>(),
          1usize,
          concat!(
            "Size of template specialization: ",
            stringify!(root::re2::re2_internal::Parse4ary)
          )
        );
        assert_eq!(
          ::std::mem::align_of::<root::re2::re2_internal::Parse4ary>(),
          1usize,
          concat!(
            "Alignment of template specialization: ",
            stringify!(root::re2::re2_internal::Parse4ary)
          )
        );
      }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct RE2_Arg {
      pub arg_: *mut ::std::os::raw::c_void,
      pub parser_: root::re2::RE2_Arg_Parser,
    }
    pub type RE2_Arg_CanParse3ary = u8;
    pub type RE2_Arg_CanParse4ary = u8;
    pub type RE2_Arg_CanParseFrom = u8;
    pub type RE2_Arg_Parser = ::std::option::Option<
      unsafe extern "C" fn(
        str_: *const ::std::os::raw::c_char,
        n: usize,
        dest: *mut ::std::os::raw::c_void,
      ) -> bool,
    >;
    #[test]
    fn bindgen_test_layout_RE2_Arg() {
      const UNINIT: ::std::mem::MaybeUninit<RE2_Arg> = ::std::mem::MaybeUninit::uninit();
      let ptr = UNINIT.as_ptr();
      assert_eq!(
        ::std::mem::size_of::<RE2_Arg>(),
        16usize,
        concat!("Size of: ", stringify!(RE2_Arg))
      );
      assert_eq!(
        ::std::mem::align_of::<RE2_Arg>(),
        8usize,
        concat!("Alignment of ", stringify!(RE2_Arg))
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arg_) as usize - ptr as usize },
        0usize,
        concat!(
          "Offset of field: ",
          stringify!(RE2_Arg),
          "::",
          stringify!(arg_)
        )
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parser_) as usize - ptr as usize },
        8usize,
        concat!(
          "Offset of field: ",
          stringify!(RE2_Arg),
          "::",
          stringify!(parser_)
        )
      );
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct LazyRE2 {
      pub pattern_: *const ::std::os::raw::c_char,
      pub options_: root::re2::RE2_CannedOptions,
      pub barrier_against_excess_initializers_: root::re2::LazyRE2_NoArg,
      pub ptr_: *mut root::re2::RE2,
      pub once_: root::absl::lts_20230125::once_flag,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct LazyRE2_NoArg {
      pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_LazyRE2_NoArg() {
      assert_eq!(
        ::std::mem::size_of::<LazyRE2_NoArg>(),
        1usize,
        concat!("Size of: ", stringify!(LazyRE2_NoArg))
      );
      assert_eq!(
        ::std::mem::align_of::<LazyRE2_NoArg>(),
        1usize,
        concat!("Alignment of ", stringify!(LazyRE2_NoArg))
      );
    }
    pub type LazyRE2_element_type = root::re2::RE2;
    #[test]
    fn bindgen_test_layout_LazyRE2() {
      const UNINIT: ::std::mem::MaybeUninit<LazyRE2> = ::std::mem::MaybeUninit::uninit();
      let ptr = UNINIT.as_ptr();
      assert_eq!(
        ::std::mem::size_of::<LazyRE2>(),
        32usize,
        concat!("Size of: ", stringify!(LazyRE2))
      );
      assert_eq!(
        ::std::mem::align_of::<LazyRE2>(),
        8usize,
        concat!("Alignment of ", stringify!(LazyRE2))
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pattern_) as usize - ptr as usize },
        0usize,
        concat!(
          "Offset of field: ",
          stringify!(LazyRE2),
          "::",
          stringify!(pattern_)
        )
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).options_) as usize - ptr as usize },
        8usize,
        concat!(
          "Offset of field: ",
          stringify!(LazyRE2),
          "::",
          stringify!(options_)
        )
      );
      assert_eq!(
        unsafe {
          ::std::ptr::addr_of!((*ptr).barrier_against_excess_initializers_) as usize - ptr as usize
        },
        12usize,
        concat!(
          "Offset of field: ",
          stringify!(LazyRE2),
          "::",
          stringify!(barrier_against_excess_initializers_)
        )
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr_) as usize - ptr as usize },
        16usize,
        concat!(
          "Offset of field: ",
          stringify!(LazyRE2),
          "::",
          stringify!(ptr_)
        )
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).once_) as usize - ptr as usize },
        24usize,
        concat!(
          "Offset of field: ",
          stringify!(LazyRE2),
          "::",
          stringify!(once_)
        )
      );
    }
    pub mod hooks {
      #[allow(unused_imports)]
      use self::super::super::super::root;
      extern "C" {
        #[link_name = "\u{1}_ZN3re25hooks7contextE"]
        pub static mut context: *const root::re2::RE2;
      }
      #[repr(C)]
      #[derive(Debug, Copy, Clone)]
      pub struct DFAStateCacheReset {
        pub state_budget: i64,
        pub state_cache_size: usize,
      }
      #[test]
      fn bindgen_test_layout_DFAStateCacheReset() {
        const UNINIT: ::std::mem::MaybeUninit<DFAStateCacheReset> =
          ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
          ::std::mem::size_of::<DFAStateCacheReset>(),
          16usize,
          concat!("Size of: ", stringify!(DFAStateCacheReset))
        );
        assert_eq!(
          ::std::mem::align_of::<DFAStateCacheReset>(),
          8usize,
          concat!("Alignment of ", stringify!(DFAStateCacheReset))
        );
        assert_eq!(
          unsafe { ::std::ptr::addr_of!((*ptr).state_budget) as usize - ptr as usize },
          0usize,
          concat!(
            "Offset of field: ",
            stringify!(DFAStateCacheReset),
            "::",
            stringify!(state_budget)
          )
        );
        assert_eq!(
          unsafe { ::std::ptr::addr_of!((*ptr).state_cache_size) as usize - ptr as usize },
          8usize,
          concat!(
            "Offset of field: ",
            stringify!(DFAStateCacheReset),
            "::",
            stringify!(state_cache_size)
          )
        );
      }
      #[repr(C)]
      #[derive(Debug, Copy, Clone)]
      pub struct DFASearchFailure {
        pub _address: u8,
      }
      #[test]
      fn bindgen_test_layout_DFASearchFailure() {
        assert_eq!(
          ::std::mem::size_of::<DFASearchFailure>(),
          1usize,
          concat!("Size of: ", stringify!(DFASearchFailure))
        );
        assert_eq!(
          ::std::mem::align_of::<DFASearchFailure>(),
          1usize,
          concat!("Alignment of ", stringify!(DFASearchFailure))
        );
      }
      pub type DFAStateCacheResetCallback = ::std::option::Option<
        unsafe extern "C" fn(arg1: *const root::re2::hooks::DFAStateCacheReset),
      >;
      extern "C" {
        #[link_name = "\u{1}_ZN3re25hooks25SetDFAStateCacheResetHookEPFvRKNS0_18DFAStateCacheResetEE"]
        pub fn SetDFAStateCacheResetHook(cb: root::re2::hooks::DFAStateCacheResetCallback);
      }
      extern "C" {
        #[link_name = "\u{1}_ZN3re25hooks25GetDFAStateCacheResetHookEv"]
        pub fn GetDFAStateCacheResetHook() -> root::re2::hooks::DFAStateCacheResetCallback;
      }
      pub type DFASearchFailureCallback = ::std::option::Option<
        unsafe extern "C" fn(arg1: *const root::re2::hooks::DFASearchFailure),
      >;
      extern "C" {
        #[link_name = "\u{1}_ZN3re25hooks23SetDFASearchFailureHookEPFvRKNS0_16DFASearchFailureEE"]
        pub fn SetDFASearchFailureHook(cb: root::re2::hooks::DFASearchFailureCallback);
      }
      extern "C" {
        #[link_name = "\u{1}_ZN3re25hooks23GetDFASearchFailureHookEv"]
        pub fn GetDFASearchFailureHook() -> root::re2::hooks::DFASearchFailureCallback;
      }
    }
  }
  pub mod re2_c_bindings {
    #[allow(unused_imports)]
    use self::super::super::root;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct StringView {
      pub data_: *const ::std::os::raw::c_char,
      pub len_: usize,
    }
    #[test]
    fn bindgen_test_layout_StringView() {
      const UNINIT: ::std::mem::MaybeUninit<StringView> = ::std::mem::MaybeUninit::uninit();
      let ptr = UNINIT.as_ptr();
      assert_eq!(
        ::std::mem::size_of::<StringView>(),
        16usize,
        concat!("Size of: ", stringify!(StringView))
      );
      assert_eq!(
        ::std::mem::align_of::<StringView>(),
        8usize,
        concat!("Alignment of ", stringify!(StringView))
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data_) as usize - ptr as usize },
        0usize,
        concat!(
          "Offset of field: ",
          stringify!(StringView),
          "::",
          stringify!(data_)
        )
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len_) as usize - ptr as usize },
        8usize,
        concat!(
          "Offset of field: ",
          stringify!(StringView),
          "::",
          stringify!(len_)
        )
      );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct StringWrapper {
      pub inner_: *mut root::std::string,
    }
    #[test]
    fn bindgen_test_layout_StringWrapper() {
      const UNINIT: ::std::mem::MaybeUninit<StringWrapper> = ::std::mem::MaybeUninit::uninit();
      let ptr = UNINIT.as_ptr();
      assert_eq!(
        ::std::mem::size_of::<StringWrapper>(),
        8usize,
        concat!("Size of: ", stringify!(StringWrapper))
      );
      assert_eq!(
        ::std::mem::align_of::<StringWrapper>(),
        8usize,
        concat!("Alignment of ", stringify!(StringWrapper))
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inner_) as usize - ptr as usize },
        0usize,
        concat!(
          "Offset of field: ",
          stringify!(StringWrapper),
          "::",
          stringify!(inner_)
        )
      );
    }
    extern "C" {
      #[link_name = "\u{1}_ZN14re2_c_bindings13StringWrapper5clearEv"]
      pub fn StringWrapper_clear(this: *mut root::re2_c_bindings::StringWrapper);
    }
    extern "C" {
      #[link_name = "\u{1}_ZNK14re2_c_bindings13StringWrapper7as_viewEv"]
      pub fn StringWrapper_as_view(
        this: *const root::re2_c_bindings::StringWrapper,
      ) -> root::re2_c_bindings::StringView;
    }
    extern "C" {
      #[link_name = "\u{1}_ZN14re2_c_bindings13StringWrapperC1Ev"]
      pub fn StringWrapper_StringWrapper(this: *mut root::re2_c_bindings::StringWrapper);
    }
    extern "C" {
      #[link_name = "\u{1}_ZN14re2_c_bindings13StringWrapperC1ENS_10StringViewE"]
      pub fn StringWrapper_StringWrapper1(
        this: *mut root::re2_c_bindings::StringWrapper,
        s: root::re2_c_bindings::StringView,
      );
    }
    impl StringWrapper {
      #[inline]
      pub unsafe fn clear(&mut self) { StringWrapper_clear(self) }

      #[inline]
      pub unsafe fn as_view(&self) -> root::re2_c_bindings::StringView {
        StringWrapper_as_view(self)
      }

      #[inline]
      pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        StringWrapper_StringWrapper(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
      }

      #[inline]
      pub unsafe fn new1(s: root::re2_c_bindings::StringView) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        StringWrapper_StringWrapper1(__bindgen_tmp.as_mut_ptr(), s);
        __bindgen_tmp.assume_init()
      }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct NamedGroup {
      pub name_: root::re2_c_bindings::StringView,
      pub index_: usize,
    }
    #[test]
    fn bindgen_test_layout_NamedGroup() {
      const UNINIT: ::std::mem::MaybeUninit<NamedGroup> = ::std::mem::MaybeUninit::uninit();
      let ptr = UNINIT.as_ptr();
      assert_eq!(
        ::std::mem::size_of::<NamedGroup>(),
        24usize,
        concat!("Size of: ", stringify!(NamedGroup))
      );
      assert_eq!(
        ::std::mem::align_of::<NamedGroup>(),
        8usize,
        concat!("Alignment of ", stringify!(NamedGroup))
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name_) as usize - ptr as usize },
        0usize,
        concat!(
          "Offset of field: ",
          stringify!(NamedGroup),
          "::",
          stringify!(name_)
        )
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index_) as usize - ptr as usize },
        16usize,
        concat!(
          "Offset of field: ",
          stringify!(NamedGroup),
          "::",
          stringify!(index_)
        )
      );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct NamedCapturingGroups {
      pub named_groups_: *const [u64; 6usize],
      pub it_: u64,
    }
    #[test]
    fn bindgen_test_layout_NamedCapturingGroups() {
      const UNINIT: ::std::mem::MaybeUninit<NamedCapturingGroups> =
        ::std::mem::MaybeUninit::uninit();
      let ptr = UNINIT.as_ptr();
      assert_eq!(
        ::std::mem::size_of::<NamedCapturingGroups>(),
        16usize,
        concat!("Size of: ", stringify!(NamedCapturingGroups))
      );
      assert_eq!(
        ::std::mem::align_of::<NamedCapturingGroups>(),
        8usize,
        concat!("Alignment of ", stringify!(NamedCapturingGroups))
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).named_groups_) as usize - ptr as usize },
        0usize,
        concat!(
          "Offset of field: ",
          stringify!(NamedCapturingGroups),
          "::",
          stringify!(named_groups_)
        )
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_) as usize - ptr as usize },
        8usize,
        concat!(
          "Offset of field: ",
          stringify!(NamedCapturingGroups),
          "::",
          stringify!(it_)
        )
      );
    }
    extern "C" {
      #[link_name = "\u{1}_ZNK14re2_c_bindings20NamedCapturingGroups5derefEPNS_10NamedGroupE"]
      pub fn NamedCapturingGroups_deref(
        this: *const root::re2_c_bindings::NamedCapturingGroups,
        out: *mut root::re2_c_bindings::NamedGroup,
      );
    }
    extern "C" {
      #[link_name = "\u{1}_ZN14re2_c_bindings20NamedCapturingGroups7advanceEv"]
      pub fn NamedCapturingGroups_advance(this: *mut root::re2_c_bindings::NamedCapturingGroups);
    }
    extern "C" {
      #[link_name = "\u{1}_ZNK14re2_c_bindings20NamedCapturingGroups9completedEv"]
      pub fn NamedCapturingGroups_completed(
        this: *const root::re2_c_bindings::NamedCapturingGroups,
      ) -> bool;
    }
    impl NamedCapturingGroups {
      #[inline]
      pub unsafe fn deref(&self, out: *mut root::re2_c_bindings::NamedGroup) {
        NamedCapturingGroups_deref(self, out)
      }

      #[inline]
      pub unsafe fn advance(&mut self) { NamedCapturingGroups_advance(self) }

      #[inline]
      pub unsafe fn completed(&self) -> bool { NamedCapturingGroups_completed(self) }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct RE2Wrapper {
      pub re_: *mut root::re2::RE2,
    }
    #[test]
    fn bindgen_test_layout_RE2Wrapper() {
      const UNINIT: ::std::mem::MaybeUninit<RE2Wrapper> = ::std::mem::MaybeUninit::uninit();
      let ptr = UNINIT.as_ptr();
      assert_eq!(
        ::std::mem::size_of::<RE2Wrapper>(),
        8usize,
        concat!("Size of: ", stringify!(RE2Wrapper))
      );
      assert_eq!(
        ::std::mem::align_of::<RE2Wrapper>(),
        8usize,
        concat!("Alignment of ", stringify!(RE2Wrapper))
      );
      assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).re_) as usize - ptr as usize },
        0usize,
        concat!(
          "Offset of field: ",
          stringify!(RE2Wrapper),
          "::",
          stringify!(re_)
        )
      );
    }
    extern "C" {
      #[link_name = "\u{1}_ZN14re2_c_bindings10RE2Wrapper10quote_metaENS_10StringViewEPNS_13StringWrapperE"]
      pub fn RE2Wrapper_quote_meta(
        pattern: root::re2_c_bindings::StringView,
        out: *mut root::re2_c_bindings::StringWrapper,
      );
    }
    extern "C" {
      #[link_name = "\u{1}_ZN14re2_c_bindings10RE2Wrapper5clearEv"]
      pub fn RE2Wrapper_clear(this: *mut root::re2_c_bindings::RE2Wrapper);
    }
    extern "C" {
      #[link_name = "\u{1}_ZNK14re2_c_bindings10RE2Wrapper10error_codeEv"]
      pub fn RE2Wrapper_error_code(
        this: *const root::re2_c_bindings::RE2Wrapper,
      ) -> root::re2::RE2_ErrorCode;
    }
    extern "C" {
      #[link_name = "\u{1}_ZNK14re2_c_bindings10RE2Wrapper7patternEv"]
      pub fn RE2Wrapper_pattern(
        this: *const root::re2_c_bindings::RE2Wrapper,
      ) -> root::re2_c_bindings::StringView;
    }
    extern "C" {
      #[link_name = "\u{1}_ZNK14re2_c_bindings10RE2Wrapper5errorEv"]
      pub fn RE2Wrapper_error(
        this: *const root::re2_c_bindings::RE2Wrapper,
      ) -> root::re2_c_bindings::StringView;
    }
    extern "C" {
      #[link_name = "\u{1}_ZNK14re2_c_bindings10RE2Wrapper9error_argEv"]
      pub fn RE2Wrapper_error_arg(
        this: *const root::re2_c_bindings::RE2Wrapper,
      ) -> root::re2_c_bindings::StringView;
    }
    extern "C" {
      #[link_name = "\u{1}_ZNK14re2_c_bindings10RE2Wrapper12num_capturesEv"]
      pub fn RE2Wrapper_num_captures(this: *const root::re2_c_bindings::RE2Wrapper) -> usize;
    }
    extern "C" {
      #[link_name = "\u{1}_ZNK14re2_c_bindings10RE2Wrapper12named_groupsEv"]
      pub fn RE2Wrapper_named_groups(
        this: *const root::re2_c_bindings::RE2Wrapper,
      ) -> root::re2_c_bindings::NamedCapturingGroups;
    }
    extern "C" {
      #[link_name = "\u{1}_ZNK14re2_c_bindings10RE2Wrapper10full_matchENS_10StringViewE"]
      pub fn RE2Wrapper_full_match(
        this: *const root::re2_c_bindings::RE2Wrapper,
        text: root::re2_c_bindings::StringView,
      ) -> bool;
    }
    extern "C" {
      #[link_name = "\u{1}_ZNK14re2_c_bindings10RE2Wrapper12full_match_nENS_10StringViewEPS1_m"]
      pub fn RE2Wrapper_full_match_n(
        this: *const root::re2_c_bindings::RE2Wrapper,
        text: root::re2_c_bindings::StringView,
        captures: *mut root::re2_c_bindings::StringView,
        n: usize,
      ) -> bool;
    }
    extern "C" {
      #[link_name = "\u{1}_ZNK14re2_c_bindings10RE2Wrapper13partial_matchENS_10StringViewE"]
      pub fn RE2Wrapper_partial_match(
        this: *const root::re2_c_bindings::RE2Wrapper,
        text: root::re2_c_bindings::StringView,
      ) -> bool;
    }
    extern "C" {
      #[link_name = "\u{1}_ZNK14re2_c_bindings10RE2Wrapper15partial_match_nENS_10StringViewEPS1_m"]
      pub fn RE2Wrapper_partial_match_n(
        this: *const root::re2_c_bindings::RE2Wrapper,
        text: root::re2_c_bindings::StringView,
        captures: *mut root::re2_c_bindings::StringView,
        n: usize,
      ) -> bool;
    }
    extern "C" {
      #[link_name = "\u{1}_ZNK14re2_c_bindings10RE2Wrapper7consumeEPNS_10StringViewE"]
      pub fn RE2Wrapper_consume(
        this: *const root::re2_c_bindings::RE2Wrapper,
        text: *mut root::re2_c_bindings::StringView,
      ) -> bool;
    }
    extern "C" {
      #[link_name = "\u{1}_ZNK14re2_c_bindings10RE2Wrapper9consume_nEPNS_10StringViewES2_m"]
      pub fn RE2Wrapper_consume_n(
        this: *const root::re2_c_bindings::RE2Wrapper,
        text: *mut root::re2_c_bindings::StringView,
        captures: *mut root::re2_c_bindings::StringView,
        n: usize,
      ) -> bool;
    }
    extern "C" {
      #[link_name = "\u{1}_ZNK14re2_c_bindings10RE2Wrapper16find_and_consumeEPNS_10StringViewE"]
      pub fn RE2Wrapper_find_and_consume(
        this: *const root::re2_c_bindings::RE2Wrapper,
        text: *mut root::re2_c_bindings::StringView,
      ) -> bool;
    }
    extern "C" {
      #[link_name = "\u{1}_ZNK14re2_c_bindings10RE2Wrapper18find_and_consume_nEPNS_10StringViewES2_m"]
      pub fn RE2Wrapper_find_and_consume_n(
        this: *const root::re2_c_bindings::RE2Wrapper,
        text: *mut root::re2_c_bindings::StringView,
        captures: *mut root::re2_c_bindings::StringView,
        n: usize,
      ) -> bool;
    }
    extern "C" {
      #[link_name = "\u{1}_ZNK14re2_c_bindings10RE2Wrapper7replaceEPNS_13StringWrapperENS_10StringViewE"]
      pub fn RE2Wrapper_replace(
        this: *const root::re2_c_bindings::RE2Wrapper,
        inout: *mut root::re2_c_bindings::StringWrapper,
        rewrite: root::re2_c_bindings::StringView,
      ) -> bool;
    }
    extern "C" {
      #[link_name = "\u{1}_ZNK14re2_c_bindings10RE2Wrapper14global_replaceEPNS_13StringWrapperENS_10StringViewE"]
      pub fn RE2Wrapper_global_replace(
        this: *const root::re2_c_bindings::RE2Wrapper,
        inout: *mut root::re2_c_bindings::StringWrapper,
        rewrite: root::re2_c_bindings::StringView,
      ) -> usize;
    }
    extern "C" {
      #[link_name = "\u{1}_ZNK14re2_c_bindings10RE2Wrapper7extractENS_10StringViewES1_PNS_13StringWrapperE"]
      pub fn RE2Wrapper_extract(
        this: *const root::re2_c_bindings::RE2Wrapper,
        text: root::re2_c_bindings::StringView,
        rewrite: root::re2_c_bindings::StringView,
        out: *mut root::re2_c_bindings::StringWrapper,
      ) -> bool;
    }
    extern "C" {
      #[link_name = "\u{1}_ZN14re2_c_bindings10RE2WrapperC1ENS_10StringViewERKN3re23RE27OptionsE"]
      pub fn RE2Wrapper_RE2Wrapper(
        this: *mut root::re2_c_bindings::RE2Wrapper,
        pattern: root::re2_c_bindings::StringView,
        options: *const root::re2::RE2_Options,
      );
    }
    impl RE2Wrapper {
      #[inline]
      pub unsafe fn quote_meta(
        pattern: root::re2_c_bindings::StringView,
        out: *mut root::re2_c_bindings::StringWrapper,
      ) {
        RE2Wrapper_quote_meta(pattern, out)
      }

      #[inline]
      pub unsafe fn clear(&mut self) { RE2Wrapper_clear(self) }

      #[inline]
      pub unsafe fn error_code(&self) -> root::re2::RE2_ErrorCode { RE2Wrapper_error_code(self) }

      #[inline]
      pub unsafe fn pattern(&self) -> root::re2_c_bindings::StringView { RE2Wrapper_pattern(self) }

      #[inline]
      pub unsafe fn error(&self) -> root::re2_c_bindings::StringView { RE2Wrapper_error(self) }

      #[inline]
      pub unsafe fn error_arg(&self) -> root::re2_c_bindings::StringView {
        RE2Wrapper_error_arg(self)
      }

      #[inline]
      pub unsafe fn num_captures(&self) -> usize { RE2Wrapper_num_captures(self) }

      #[inline]
      pub unsafe fn named_groups(&self) -> root::re2_c_bindings::NamedCapturingGroups {
        RE2Wrapper_named_groups(self)
      }

      #[inline]
      pub unsafe fn full_match(&self, text: root::re2_c_bindings::StringView) -> bool {
        RE2Wrapper_full_match(self, text)
      }

      #[inline]
      pub unsafe fn full_match_n(
        &self,
        text: root::re2_c_bindings::StringView,
        captures: *mut root::re2_c_bindings::StringView,
        n: usize,
      ) -> bool {
        RE2Wrapper_full_match_n(self, text, captures, n)
      }

      #[inline]
      pub unsafe fn partial_match(&self, text: root::re2_c_bindings::StringView) -> bool {
        RE2Wrapper_partial_match(self, text)
      }

      #[inline]
      pub unsafe fn partial_match_n(
        &self,
        text: root::re2_c_bindings::StringView,
        captures: *mut root::re2_c_bindings::StringView,
        n: usize,
      ) -> bool {
        RE2Wrapper_partial_match_n(self, text, captures, n)
      }

      #[inline]
      pub unsafe fn consume(&self, text: *mut root::re2_c_bindings::StringView) -> bool {
        RE2Wrapper_consume(self, text)
      }

      #[inline]
      pub unsafe fn consume_n(
        &self,
        text: *mut root::re2_c_bindings::StringView,
        captures: *mut root::re2_c_bindings::StringView,
        n: usize,
      ) -> bool {
        RE2Wrapper_consume_n(self, text, captures, n)
      }

      #[inline]
      pub unsafe fn find_and_consume(&self, text: *mut root::re2_c_bindings::StringView) -> bool {
        RE2Wrapper_find_and_consume(self, text)
      }

      #[inline]
      pub unsafe fn find_and_consume_n(
        &self,
        text: *mut root::re2_c_bindings::StringView,
        captures: *mut root::re2_c_bindings::StringView,
        n: usize,
      ) -> bool {
        RE2Wrapper_find_and_consume_n(self, text, captures, n)
      }

      #[inline]
      pub unsafe fn replace(
        &self,
        inout: *mut root::re2_c_bindings::StringWrapper,
        rewrite: root::re2_c_bindings::StringView,
      ) -> bool {
        RE2Wrapper_replace(self, inout, rewrite)
      }

      #[inline]
      pub unsafe fn global_replace(
        &self,
        inout: *mut root::re2_c_bindings::StringWrapper,
        rewrite: root::re2_c_bindings::StringView,
      ) -> usize {
        RE2Wrapper_global_replace(self, inout, rewrite)
      }

      #[inline]
      pub unsafe fn extract(
        &self,
        text: root::re2_c_bindings::StringView,
        rewrite: root::re2_c_bindings::StringView,
        out: *mut root::re2_c_bindings::StringWrapper,
      ) -> bool {
        RE2Wrapper_extract(self, text, rewrite, out)
      }

      #[inline]
      pub unsafe fn new(
        pattern: root::re2_c_bindings::StringView,
        options: *const root::re2::RE2_Options,
      ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        RE2Wrapper_RE2Wrapper(__bindgen_tmp.as_mut_ptr(), pattern, options);
        __bindgen_tmp.assume_init()
      }
    }
  }
}
