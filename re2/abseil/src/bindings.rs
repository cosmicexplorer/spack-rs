/* automatically generated by rust-bindgen 0.69.1 */

#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
pub mod root {
  #[repr(C)]
  pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
  impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self { __BindgenUnionField(::std::marker::PhantomData) }

    #[inline]
    pub unsafe fn as_ref(&self) -> &T { ::std::mem::transmute(self) }

    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T { ::std::mem::transmute(self) }
  }
  impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self { Self::new() }
  }
  impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self { *self }
  }
  impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
  impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
      fmt.write_str("__BindgenUnionField")
    }
  }
  impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
  }
  impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool { true }
  }
  impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
  #[allow(unused_imports)]
  use self::super::root;
  pub mod std {
    #[allow(unused_imports)]
    use self::super::super::root;
    pub type integral_constant_value_type = u8;
    pub type integral_constant_type = u8;
    pub type true_type = u8;
    pub type false_type = u8;
    pub mod __detail {
      #[allow(unused_imports)]
      use self::super::super::super::root;
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct is_trivially_copyable {
      pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct is_trivially_default_constructible {
      pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct is_trivially_move_constructible {
      pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct is_trivially_copy_assignable {
      pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct is_trivially_destructible {
      pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct remove_const {
      pub _address: u8,
    }
    pub type remove_const_type = u8;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct remove_volatile {
      pub _address: u8,
    }
    pub type remove_volatile_type = u8;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct remove_cv {
      pub _address: u8,
    }
    pub type remove_cv_type = u8;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct add_const {
      pub _address: u8,
    }
    pub type add_const_type = u8;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct add_volatile {
      pub _address: u8,
    }
    pub type add_volatile_type = u8;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct add_cv {
      pub _address: u8,
    }
    pub type add_cv_type = u8;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct remove_reference {
      pub _address: u8,
    }
    pub type remove_reference_type = u8;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct add_lvalue_reference {
      pub _address: u8,
    }
    pub type add_lvalue_reference_type = u8;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct add_rvalue_reference {
      pub _address: u8,
    }
    pub type add_rvalue_reference_type = u8;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct make_unsigned {
      pub _address: u8,
    }
    pub type make_unsigned_type = u8;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct make_signed {
      pub _address: u8,
    }
    pub type make_signed_type = u8;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct remove_extent {
      pub _address: u8,
    }
    pub type remove_extent_type = u8;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct remove_all_extents {
      pub _address: u8,
    }
    pub type remove_all_extents_type = u8;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct remove_pointer {
      pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct add_pointer {
      pub _address: u8,
    }
    #[repr(C)]
    #[repr(align(8))]
    #[derive(Copy, Clone)]
    pub union aligned_storage_type {
      pub _bindgen_opaque_blob: u64,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct aligned_storage_type__bindgen_ty_1 {
      pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_aligned_storage_type() {
      assert_eq!(
        ::std::mem::size_of::<aligned_storage_type>(),
        8usize,
        concat!("Size of: ", stringify!(aligned_storage_type))
      );
      assert_eq!(
        ::std::mem::align_of::<aligned_storage_type>(),
        8usize,
        concat!("Alignment of ", stringify!(aligned_storage_type))
      );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct decay {
      pub _address: u8,
    }
    pub type decay_type = u8;
    pub type conditional_type = u8;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct common_type {
      pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct underlying_type {
      pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct remove_cvref {
      pub _address: u8,
    }
    pub type remove_cvref_type = u8;
    pub mod ranges {
      #[allow(unused_imports)]
      use self::super::super::super::root;
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct atomic {
      pub _address: u8,
    }
    pub type atomic_value_type = u8;
    pub type array_value_type = u8;
    pub type array_pointer = u8;
    pub type array_const_pointer = u8;
    pub type array_reference = u8;
    pub type array_const_reference = u8;
    pub type array_iterator = u8;
    pub type array_const_iterator = u8;
    pub type array_size_type = u64;
    pub type array_difference_type = u64;
    pub type array_reverse_iterator = u8;
    pub type array_const_reverse_iterator = u8;
    pub type string = [u64; 4usize];
    pub type string_view = [u64; 2usize];
  }
  pub mod __gnu_cxx {
    #[allow(unused_imports)]
    use self::super::super::root;
  }
  pub mod __pstl {
    #[allow(unused_imports)]
    use self::super::super::root;
    pub mod execution {
      #[allow(unused_imports)]
      use self::super::super::super::root;
    }
  }
  pub mod absl {
    #[allow(unused_imports)]
    use self::super::super::root;
    pub mod lts_20230125 {
      #[allow(unused_imports)]
      use self::super::super::super::root;
      pub mod base_internal {
        #[allow(unused_imports)]
        use self::super::super::super::super::root;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AtomicHook {
          pub _address: u8,
        }
        pub const SchedulingMode_SCHEDULE_KERNEL_ONLY:
          root::absl::lts_20230125::base_internal::SchedulingMode = 0;
        pub const SchedulingMode_SCHEDULE_COOPERATIVE_AND_KERNEL:
          root::absl::lts_20230125::base_internal::SchedulingMode = 1;
        pub type SchedulingMode = ::std::os::raw::c_uint;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SpinLock {
          _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SchedulingGuard {
          pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct SchedulingGuard_ScopedDisable {
          pub disabled: bool,
        }
        #[test]
        fn bindgen_test_layout_SchedulingGuard_ScopedDisable() {
          const UNINIT: ::std::mem::MaybeUninit<SchedulingGuard_ScopedDisable> =
            ::std::mem::MaybeUninit::uninit();
          let ptr = UNINIT.as_ptr();
          assert_eq!(
            ::std::mem::size_of::<SchedulingGuard_ScopedDisable>(),
            1usize,
            concat!("Size of: ", stringify!(SchedulingGuard_ScopedDisable))
          );
          assert_eq!(
            ::std::mem::align_of::<SchedulingGuard_ScopedDisable>(),
            1usize,
            concat!("Alignment of ", stringify!(SchedulingGuard_ScopedDisable))
          );
          assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).disabled) as usize - ptr as usize },
            0usize,
            concat!(
              "Offset of field: ",
              stringify!(SchedulingGuard_ScopedDisable),
              "::",
              stringify!(disabled)
            )
          );
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct SchedulingGuard_ScopedEnable {
          pub scheduling_disabled_depth_: ::std::os::raw::c_int,
        }
        #[test]
        fn bindgen_test_layout_SchedulingGuard_ScopedEnable() {
          const UNINIT: ::std::mem::MaybeUninit<SchedulingGuard_ScopedEnable> =
            ::std::mem::MaybeUninit::uninit();
          let ptr = UNINIT.as_ptr();
          assert_eq!(
            ::std::mem::size_of::<SchedulingGuard_ScopedEnable>(),
            4usize,
            concat!("Size of: ", stringify!(SchedulingGuard_ScopedEnable))
          );
          assert_eq!(
            ::std::mem::align_of::<SchedulingGuard_ScopedEnable>(),
            4usize,
            concat!("Alignment of ", stringify!(SchedulingGuard_ScopedEnable))
          );
          assert_eq!(
            unsafe {
              ::std::ptr::addr_of!((*ptr).scheduling_disabled_depth_) as usize - ptr as usize
            },
            0usize,
            concat!(
              "Offset of field: ",
              stringify!(SchedulingGuard_ScopedEnable),
              "::",
              stringify!(scheduling_disabled_depth_)
            )
          );
        }
        #[test]
        fn bindgen_test_layout_SchedulingGuard() {
          assert_eq!(
            ::std::mem::size_of::<SchedulingGuard>(),
            1usize,
            concat!("Size of: ", stringify!(SchedulingGuard))
          );
          assert_eq!(
            ::std::mem::align_of::<SchedulingGuard>(),
            1usize,
            concat!("Alignment of ", stringify!(SchedulingGuard))
          );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SpinLockWaitTransition {
          pub from: u32,
          pub to: u32,
          pub done: bool,
        }
        #[test]
        fn bindgen_test_layout_SpinLockWaitTransition() {
          const UNINIT: ::std::mem::MaybeUninit<SpinLockWaitTransition> =
            ::std::mem::MaybeUninit::uninit();
          let ptr = UNINIT.as_ptr();
          assert_eq!(
            ::std::mem::size_of::<SpinLockWaitTransition>(),
            12usize,
            concat!("Size of: ", stringify!(SpinLockWaitTransition))
          );
          assert_eq!(
            ::std::mem::align_of::<SpinLockWaitTransition>(),
            4usize,
            concat!("Alignment of ", stringify!(SpinLockWaitTransition))
          );
          assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).from) as usize - ptr as usize },
            0usize,
            concat!(
              "Offset of field: ",
              stringify!(SpinLockWaitTransition),
              "::",
              stringify!(from)
            )
          );
          assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).to) as usize - ptr as usize },
            4usize,
            concat!(
              "Offset of field: ",
              stringify!(SpinLockWaitTransition),
              "::",
              stringify!(to)
            )
          );
          assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).done) as usize - ptr as usize },
            8usize,
            concat!(
              "Offset of field: ",
              stringify!(SpinLockWaitTransition),
              "::",
              stringify!(done)
            )
          );
        }
        extern "C" {
          #[link_name = "\u{1}_ZN4absl12lts_2023012513base_internal12SpinLockWaitEPSt6atomicIjEiPKNS1_22SpinLockWaitTransitionENS1_14SchedulingModeE"]
          pub fn SpinLockWait(
            w: *mut u32,
            n: ::std::os::raw::c_int,
            trans: *const root::absl::lts_20230125::base_internal::SpinLockWaitTransition,
            scheduling_mode: root::absl::lts_20230125::base_internal::SchedulingMode,
          ) -> u32;
        }
        extern "C" {
          #[link_name = "\u{1}_ZN4absl12lts_2023012513base_internal24SpinLockSuggestedDelayNSEi"]
          pub fn SpinLockSuggestedDelayNS(loop_: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct SchedulingHelper {
          pub mode_: root::absl::lts_20230125::base_internal::SchedulingMode,
          pub guard_result_: bool,
        }
        #[test]
        fn bindgen_test_layout_SchedulingHelper() {
          const UNINIT: ::std::mem::MaybeUninit<SchedulingHelper> =
            ::std::mem::MaybeUninit::uninit();
          let ptr = UNINIT.as_ptr();
          assert_eq!(
            ::std::mem::size_of::<SchedulingHelper>(),
            8usize,
            concat!("Size of: ", stringify!(SchedulingHelper))
          );
          assert_eq!(
            ::std::mem::align_of::<SchedulingHelper>(),
            4usize,
            concat!("Alignment of ", stringify!(SchedulingHelper))
          );
          assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).mode_) as usize - ptr as usize },
            0usize,
            concat!(
              "Offset of field: ",
              stringify!(SchedulingHelper),
              "::",
              stringify!(mode_)
            )
          );
          assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).guard_result_) as usize - ptr as usize },
            4usize,
            concat!(
              "Offset of field: ",
              stringify!(SchedulingHelper),
              "::",
              stringify!(guard_result_)
            )
          );
        }
        pub const base_internal_kOnceInit: root::absl::lts_20230125::base_internal::_bindgen_ty_1 =
          0;
        pub const base_internal_kOnceRunning:
          root::absl::lts_20230125::base_internal::_bindgen_ty_1 = 1707250555;
        pub const base_internal_kOnceWaiter:
          root::absl::lts_20230125::base_internal::_bindgen_ty_1 = 94570706;
        pub const base_internal_kOnceDone: root::absl::lts_20230125::base_internal::_bindgen_ty_1 =
          221;
        pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
        extern "C" {
          #[link_name = "\u{1}_ZN4absl12lts_2023012513base_internal18ThrowStdLogicErrorERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
          pub fn ThrowStdLogicError(what_arg: *const root::std::string);
        }
        extern "C" {
          #[link_name = "\u{1}_ZN4absl12lts_2023012513base_internal18ThrowStdLogicErrorEPKc"]
          pub fn ThrowStdLogicError1(what_arg: *const ::std::os::raw::c_char);
        }
        extern "C" {
          #[link_name = "\u{1}_ZN4absl12lts_2023012513base_internal23ThrowStdInvalidArgumentERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
          pub fn ThrowStdInvalidArgument(what_arg: *const root::std::string);
        }
        extern "C" {
          #[link_name = "\u{1}_ZN4absl12lts_2023012513base_internal23ThrowStdInvalidArgumentEPKc"]
          pub fn ThrowStdInvalidArgument1(what_arg: *const ::std::os::raw::c_char);
        }
        extern "C" {
          #[link_name = "\u{1}_ZN4absl12lts_2023012513base_internal19ThrowStdDomainErrorERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
          pub fn ThrowStdDomainError(what_arg: *const root::std::string);
        }
        extern "C" {
          #[link_name = "\u{1}_ZN4absl12lts_2023012513base_internal19ThrowStdDomainErrorEPKc"]
          pub fn ThrowStdDomainError1(what_arg: *const ::std::os::raw::c_char);
        }
        extern "C" {
          #[link_name = "\u{1}_ZN4absl12lts_2023012513base_internal19ThrowStdLengthErrorERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
          pub fn ThrowStdLengthError(what_arg: *const root::std::string);
        }
        extern "C" {
          #[link_name = "\u{1}_ZN4absl12lts_2023012513base_internal19ThrowStdLengthErrorEPKc"]
          pub fn ThrowStdLengthError1(what_arg: *const ::std::os::raw::c_char);
        }
        extern "C" {
          #[link_name = "\u{1}_ZN4absl12lts_2023012513base_internal18ThrowStdOutOfRangeERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
          pub fn ThrowStdOutOfRange(what_arg: *const root::std::string);
        }
        extern "C" {
          #[link_name = "\u{1}_ZN4absl12lts_2023012513base_internal18ThrowStdOutOfRangeEPKc"]
          pub fn ThrowStdOutOfRange1(what_arg: *const ::std::os::raw::c_char);
        }
        extern "C" {
          #[link_name = "\u{1}_ZN4absl12lts_2023012513base_internal20ThrowStdRuntimeErrorERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
          pub fn ThrowStdRuntimeError(what_arg: *const root::std::string);
        }
        extern "C" {
          #[link_name = "\u{1}_ZN4absl12lts_2023012513base_internal20ThrowStdRuntimeErrorEPKc"]
          pub fn ThrowStdRuntimeError1(what_arg: *const ::std::os::raw::c_char);
        }
        extern "C" {
          #[link_name = "\u{1}_ZN4absl12lts_2023012513base_internal18ThrowStdRangeErrorERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
          pub fn ThrowStdRangeError(what_arg: *const root::std::string);
        }
        extern "C" {
          #[link_name = "\u{1}_ZN4absl12lts_2023012513base_internal18ThrowStdRangeErrorEPKc"]
          pub fn ThrowStdRangeError1(what_arg: *const ::std::os::raw::c_char);
        }
        extern "C" {
          #[link_name = "\u{1}_ZN4absl12lts_2023012513base_internal21ThrowStdOverflowErrorERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
          pub fn ThrowStdOverflowError(what_arg: *const root::std::string);
        }
        extern "C" {
          #[link_name = "\u{1}_ZN4absl12lts_2023012513base_internal21ThrowStdOverflowErrorEPKc"]
          pub fn ThrowStdOverflowError1(what_arg: *const ::std::os::raw::c_char);
        }
        extern "C" {
          #[link_name = "\u{1}_ZN4absl12lts_2023012513base_internal22ThrowStdUnderflowErrorERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
          pub fn ThrowStdUnderflowError(what_arg: *const root::std::string);
        }
        extern "C" {
          #[link_name = "\u{1}_ZN4absl12lts_2023012513base_internal22ThrowStdUnderflowErrorEPKc"]
          pub fn ThrowStdUnderflowError1(what_arg: *const ::std::os::raw::c_char);
        }
        extern "C" {
          #[link_name = "\u{1}_ZN4absl12lts_2023012513base_internal23ThrowStdBadFunctionCallEv"]
          pub fn ThrowStdBadFunctionCall();
        }
        extern "C" {
          #[link_name = "\u{1}_ZN4absl12lts_2023012513base_internal16ThrowStdBadAllocEv"]
          pub fn ThrowStdBadAlloc();
        }
      }
      pub const LogSeverity_kInfo: root::absl::lts_20230125::LogSeverity = 0;
      pub const LogSeverity_kWarning: root::absl::lts_20230125::LogSeverity = 1;
      pub const LogSeverity_kError: root::absl::lts_20230125::LogSeverity = 2;
      pub const LogSeverity_kFatal: root::absl::lts_20230125::LogSeverity = 3;
      pub type LogSeverity = ::std::os::raw::c_int;
      pub const LogSeverityAtLeast_kInfo: root::absl::lts_20230125::LogSeverityAtLeast = 0;
      pub const LogSeverityAtLeast_kWarning: root::absl::lts_20230125::LogSeverityAtLeast = 1;
      pub const LogSeverityAtLeast_kError: root::absl::lts_20230125::LogSeverityAtLeast = 2;
      pub const LogSeverityAtLeast_kFatal: root::absl::lts_20230125::LogSeverityAtLeast = 3;
      pub const LogSeverityAtLeast_kInfinity: root::absl::lts_20230125::LogSeverityAtLeast = 1000;
      pub type LogSeverityAtLeast = ::std::os::raw::c_int;
      pub const LogSeverityAtMost_kNegativeInfinity: root::absl::lts_20230125::LogSeverityAtMost =
        -1000;
      pub const LogSeverityAtMost_kInfo: root::absl::lts_20230125::LogSeverityAtMost = 0;
      pub const LogSeverityAtMost_kWarning: root::absl::lts_20230125::LogSeverityAtMost = 1;
      pub const LogSeverityAtMost_kError: root::absl::lts_20230125::LogSeverityAtMost = 2;
      pub const LogSeverityAtMost_kFatal: root::absl::lts_20230125::LogSeverityAtMost = 3;
      pub type LogSeverityAtMost = ::std::os::raw::c_int;
      pub mod raw_log_internal {
        #[allow(unused_imports)]
        use self::super::super::super::super::root;
        extern "C" {
          #[link_name = "\u{1}_ZN4absl12lts_2023012516raw_log_internal6RawLogENS0_11LogSeverityEPKciS4_z"]
          pub fn RawLog(
            severity: root::absl::lts_20230125::LogSeverity,
            file: *const ::std::os::raw::c_char,
            line: ::std::os::raw::c_int,
            format: *const ::std::os::raw::c_char,
            ...
          );
        }
        extern "C" {
          #[link_name = "\u{1}_ZN4absl12lts_2023012516raw_log_internal28AsyncSignalSafeWriteToStderrEPKcm"]
          pub fn AsyncSignalSafeWriteToStderr(s: *const ::std::os::raw::c_char, len: usize);
        }
        extern "C" {
          #[link_name = "\u{1}_ZN4absl12lts_2023012516raw_log_internal24RawLoggingFullySupportedEv"]
          pub fn RawLoggingFullySupported() -> bool;
        }
        pub type LogFilterAndPrefixHook = ::std::option::Option<
          unsafe extern "C" fn(
            severity: root::absl::lts_20230125::LogSeverity,
            file: *const ::std::os::raw::c_char,
            line: ::std::os::raw::c_int,
            buf: *mut *mut ::std::os::raw::c_char,
            buf_size: *mut ::std::os::raw::c_int,
          ) -> bool,
        >;
        pub type AbortHook = ::std::option::Option<
          unsafe extern "C" fn(
            file: *const ::std::os::raw::c_char,
            line: ::std::os::raw::c_int,
            buf_start: *const ::std::os::raw::c_char,
            prefix_end: *const ::std::os::raw::c_char,
            buf_end: *const ::std::os::raw::c_char,
          ),
        >;
        pub type InternalLogFunction = ::std::option::Option<
          unsafe extern "C" fn(
            severity: root::absl::lts_20230125::LogSeverity,
            file: *const ::std::os::raw::c_char,
            line: ::std::os::raw::c_int,
            message: *const root::std::string,
          ),
        >;
        extern "C" {
          #[link_name = "\u{1}_ZN4absl12lts_2023012516raw_log_internal21internal_log_functionB5cxx11E"]
          pub static mut internal_log_function: root::absl::lts_20230125::base_internal::AtomicHook;
        }
        extern "C" {
          #[link_name = "\u{1}_ZN4absl12lts_2023012516raw_log_internal30RegisterLogFilterAndPrefixHookEPFbNS0_11LogSeverityEPKciPPcPiE"]
          pub fn RegisterLogFilterAndPrefixHook(
            func: root::absl::lts_20230125::raw_log_internal::LogFilterAndPrefixHook,
          );
        }
        extern "C" {
          #[link_name = "\u{1}_ZN4absl12lts_2023012516raw_log_internal17RegisterAbortHookEPFvPKciS3_S3_S3_E"]
          pub fn RegisterAbortHook(func: root::absl::lts_20230125::raw_log_internal::AbortHook);
        }
        extern "C" {
          #[link_name = "\u{1}_ZN4absl12lts_2023012516raw_log_internal27RegisterInternalLogFunctionEPFvNS0_11LogSeverityEPKciRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEE"]
          pub fn RegisterInternalLogFunction(
            func: root::absl::lts_20230125::raw_log_internal::InternalLogFunction,
          );
        }
      }
      #[repr(C)]
      #[derive(Debug, Copy, Clone)]
      pub struct CondVar {
        _unused: [u8; 0],
      }
      #[repr(C)]
      #[derive(Debug, Copy, Clone)]
      pub struct Mutex {
        _unused: [u8; 0],
      }
      pub mod synchronization_internal {
        #[allow(unused_imports)]
        use self::super::super::super::super::root;
        extern "C" {
          #[link_name = "\u{1}_ZN4absl12lts_2023012524synchronization_internal10MutexDelayEii"]
          pub fn MutexDelay(c: i32, mode: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
        }
      }
      #[repr(C)]
      #[derive(Debug)]
      pub struct once_flag {
        pub control_: u32,
      }
      #[test]
      fn bindgen_test_layout_once_flag() {
        const UNINIT: ::std::mem::MaybeUninit<once_flag> = ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
          ::std::mem::size_of::<once_flag>(),
          4usize,
          concat!("Size of: ", stringify!(once_flag))
        );
        assert_eq!(
          ::std::mem::align_of::<once_flag>(),
          4usize,
          concat!("Alignment of ", stringify!(once_flag))
        );
        assert_eq!(
          unsafe { ::std::ptr::addr_of!((*ptr).control_) as usize - ptr as usize },
          0usize,
          concat!(
            "Offset of field: ",
            stringify!(once_flag),
            "::",
            stringify!(control_)
          )
        );
      }
      pub type string_view = root::std::string_view;
      pub mod internal {
        #[allow(unused_imports)]
        use self::super::super::super::super::root;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct identity {
          pub _address: u8,
        }
        pub type identity_type<T> = T;
        pub type identity_t = root::absl::lts_20230125::internal::identity;
      }
      pub mod type_traits_internal {
        #[allow(unused_imports)]
        use self::super::super::super::super::root;
        #[repr(C)]
        #[repr(align(1))]
        pub struct SingleMemberUnion<T> {
          pub t: root::__BindgenUnionField<T>,
          pub bindgen_union_field: [u8; 0usize],
          pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct IsTriviallyMoveConstructibleObject {
          pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct IsTriviallyCopyConstructibleObject {
          pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct IsTriviallyMoveAssignableReference {
          pub _base: root::std::false_type,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct VoidTImpl {
          pub _address: u8,
        }
        pub type VoidTImpl_type = ::std::os::raw::c_void;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_detected_impl {
          pub _address: u8,
        }
        pub type is_detected_impl_type = root::std::false_type;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_detected {
          pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_detected_convertible_impl {
          pub _address: u8,
        }
        pub type is_detected_convertible_impl_type = root::std::false_type;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_detected_convertible {
          pub _address: u8,
        }
        pub type IsCopyAssignableImpl<T> = T;
        pub type IsMoveAssignableImpl<T> = T;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_trivially_copyable {
          pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct result_of {
          pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct IsHashable {
          pub _base: root::std::false_type,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AssertHashEnabledHelper {
          pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AssertHashEnabledHelper_NAT {
          pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_AssertHashEnabledHelper_NAT() {
          assert_eq!(
            ::std::mem::size_of::<AssertHashEnabledHelper_NAT>(),
            1usize,
            concat!("Size of: ", stringify!(AssertHashEnabledHelper_NAT))
          );
          assert_eq!(
            ::std::mem::align_of::<AssertHashEnabledHelper_NAT>(),
            1usize,
            concat!("Alignment of ", stringify!(AssertHashEnabledHelper_NAT))
          );
        }
        #[test]
        fn bindgen_test_layout_AssertHashEnabledHelper() {
          assert_eq!(
            ::std::mem::size_of::<AssertHashEnabledHelper>(),
            1usize,
            concat!("Size of: ", stringify!(AssertHashEnabledHelper))
          );
          assert_eq!(
            ::std::mem::align_of::<AssertHashEnabledHelper>(),
            1usize,
            concat!("Alignment of ", stringify!(AssertHashEnabledHelper))
          );
        }
      }
      #[repr(C)]
      #[derive(Debug, Copy, Clone)]
      pub struct is_copy_assignable {
        pub _address: u8,
      }
      #[repr(C)]
      #[derive(Debug, Copy, Clone)]
      pub struct is_move_assignable {
        pub _address: u8,
      }
      pub type void_t = root::absl::lts_20230125::type_traits_internal::VoidTImpl;
      #[repr(C)]
      #[derive(Debug, Copy, Clone)]
      pub struct conjunction {
        pub _base: root::std::true_type,
      }
      #[repr(C)]
      #[derive(Debug, Copy, Clone)]
      pub struct disjunction {
        pub _base: root::std::false_type,
      }
      #[repr(C)]
      #[derive(Debug, Copy, Clone)]
      pub struct negation {
        pub _address: u8,
      }
      #[repr(C)]
      #[derive(Debug, Copy, Clone)]
      pub struct is_function {
        pub _address: u8,
      }
      #[repr(C)]
      #[derive(Debug, Copy, Clone)]
      pub struct is_trivially_destructible {
        pub _address: u8,
      }
      #[repr(C)]
      #[derive(Debug, Copy, Clone)]
      pub struct is_trivially_default_constructible {
        pub _address: u8,
      }
      #[repr(C)]
      #[derive(Debug, Copy, Clone)]
      pub struct is_trivially_move_constructible {
        pub _address: u8,
      }
      #[repr(C)]
      #[derive(Debug, Copy, Clone)]
      pub struct is_trivially_copy_constructible {
        pub _address: u8,
      }
      #[repr(C)]
      #[derive(Debug, Copy, Clone)]
      pub struct is_trivially_move_assignable {
        pub _address: u8,
      }
      #[repr(C)]
      #[derive(Debug, Copy, Clone)]
      pub struct is_trivially_copy_assignable {
        pub _address: u8,
      }
      pub type remove_cvref = u8;
      pub type remove_cvref_t = u8;
      pub type remove_cv_t = u8;
      pub type remove_const_t = u8;
      pub type remove_volatile_t = u8;
      pub type add_cv_t = u8;
      pub type add_const_t = u8;
      pub type add_volatile_t = u8;
      pub type remove_reference_t = u8;
      pub type add_lvalue_reference_t = u8;
      pub type add_rvalue_reference_t = u8;
      pub type remove_pointer_t = u8;
      pub type add_pointer_t = u8;
      pub type make_signed_t = u8;
      pub type make_unsigned_t = u8;
      pub type remove_extent_t = u8;
      pub type remove_all_extents_t = u8;
      pub type aligned_storage_t = u8;
      pub type decay_t = u8;
      pub type enable_if_t = u8;
      pub type conditional_t = u8;
      pub type common_type_t = u8;
      pub type underlying_type_t = u8;
      pub type result_of_t = root::absl::lts_20230125::type_traits_internal::result_of;
      pub mod swap_internal {
        #[allow(unused_imports)]
        use self::super::super::super::super::root;
        extern "C" {
          #[link_name = "\u{1}_ZN4absl12lts_2023012513swap_internal4swapEv"]
          pub fn swap();
        }
        pub type IsSwappableImpl<T> = T;
        pub type IsNothrowSwappableImpl = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct IsSwappable {
          pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct IsNothrowSwappable {
          pub _address: u8,
        }
        pub type StdSwapIsUnconstrained = root::absl::lts_20230125::swap_internal::IsSwappable;
      }
      #[repr(C)]
      #[derive(Debug, Copy, Clone)]
      pub struct is_trivially_relocatable {
        pub _address: u8,
      }
      pub type integer_sequence_value_type<T> = T;
      pub type index_sequence = u8;
      pub mod utility_internal {
        #[allow(unused_imports)]
        use self::super::super::super::super::root;
        pub type Gen_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct InPlaceTypeTag {
          pub _address: u8,
        }
      }
      pub type make_integer_sequence = u8;
      pub type make_index_sequence = root::absl::lts_20230125::make_integer_sequence;
      pub type index_sequence_for = root::absl::lts_20230125::make_index_sequence;
    }
  }
  #[repr(C)]
  #[derive(Debug, Copy, Clone)]
  pub struct _bindgen_ty_58 {
    pub _address: u8,
  }
  #[repr(C)]
  #[derive(Debug, Copy, Clone)]
  pub struct _bindgen_ty_59 {
    pub _address: u8,
  }
  #[repr(C)]
  #[derive(Debug, Copy, Clone)]
  pub struct _bindgen_ty_60 {
    pub _address: u8,
  }
  #[repr(C)]
  #[derive(Debug, Copy, Clone)]
  pub struct _bindgen_ty_61 {
    pub _address: u8,
  }
}
