/* automatically generated by rust-bindgen 0.69.1 */

#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
pub mod root {
  #[repr(C)]
  pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
  impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self { __BindgenUnionField(::std::marker::PhantomData) }

    #[inline]
    pub unsafe fn as_ref(&self) -> &T { ::std::mem::transmute(self) }

    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T { ::std::mem::transmute(self) }
  }
  impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self { Self::new() }
  }
  impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self { *self }
  }
  impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
  impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
      fmt.write_str("__BindgenUnionField")
    }
  }
  impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
  }
  impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool { true }
  }
  impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
  #[allow(unused_imports)]
  use self::super::root;
  pub mod std {
    #[allow(unused_imports)]
    use self::super::super::root;
    pub type nullptr_t = u64;
    pub type integral_constant_value_type = u8;
    pub type integral_constant_type = u8;
    pub type true_type = u8;
    pub type false_type = u8;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct is_trivially_copyable {
      pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct is_trivially_default_constructible {
      pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct is_trivially_move_constructible {
      pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct is_trivially_copy_assignable {
      pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct is_trivially_destructible {
      pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct remove_const {
      pub _address: u8,
    }
    pub type remove_const_type = u8;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct remove_volatile {
      pub _address: u8,
    }
    pub type remove_volatile_type = u8;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct remove_cv {
      pub _address: u8,
    }
    pub type remove_cv_type = u8;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct add_const {
      pub _address: u8,
    }
    pub type add_const_type = u8;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct add_volatile {
      pub _address: u8,
    }
    pub type add_volatile_type = u8;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct add_cv {
      pub _address: u8,
    }
    pub type add_cv_type = u8;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct remove_reference {
      pub _address: u8,
    }
    pub type remove_reference_type = u8;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct add_lvalue_reference {
      pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct add_rvalue_reference {
      pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct make_unsigned {
      pub _address: u8,
    }
    pub type make_unsigned_type = u8;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct make_signed {
      pub _address: u8,
    }
    pub type make_signed_type = u8;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct remove_extent {
      pub _address: u8,
    }
    pub type remove_extent_type = u8;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct remove_all_extents {
      pub _address: u8,
    }
    pub type remove_all_extents_type = u8;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct remove_pointer {
      pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct add_pointer {
      pub _address: u8,
    }
    #[repr(C)]
    #[repr(align(8))]
    #[derive(Copy, Clone)]
    pub union aligned_storage_type {
      pub _bindgen_opaque_blob: u64,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct aligned_storage_type__bindgen_ty_1 {
      pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_aligned_storage_type() {
      assert_eq!(
        ::std::mem::size_of::<aligned_storage_type>(),
        8usize,
        concat!("Size of: ", stringify!(aligned_storage_type))
      );
      assert_eq!(
        ::std::mem::align_of::<aligned_storage_type>(),
        8usize,
        concat!("Alignment of ", stringify!(aligned_storage_type))
      );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct decay {
      pub _address: u8,
    }
    pub type decay___remove_type = u8;
    pub type decay_type = u8;
    pub type conditional_type = u8;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct common_type {
      pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct underlying_type {
      pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct result_of {
      pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct reverse_iterator {
      pub _address: u8,
    }
    pub type reverse_iterator___traits_type = u8;
    pub type reverse_iterator_iterator_type = u8;
    pub type reverse_iterator_pointer = u8;
    pub type reverse_iterator_difference_type = u8;
    pub type reverse_iterator_reference = u8;
    #[repr(C)]
    #[repr(align(8))]
    #[derive(Debug, Copy, Clone)]
    pub struct exception {
      pub _bindgen_opaque_blob: u64,
    }
    #[test]
    fn bindgen_test_layout_exception() {
      assert_eq!(
        ::std::mem::size_of::<exception>(),
        8usize,
        concat!("Size of: ", stringify!(exception))
      );
      assert_eq!(
        ::std::mem::align_of::<exception>(),
        8usize,
        concat!("Alignment of ", stringify!(exception))
      );
    }
    extern "C" {
      #[link_name = "\u{1}_ZNSt9exceptionD1Ev"]
      pub fn exception_exception_destructor(this: *mut root::std::exception);
    }
    extern "C" {
      #[link_name = "\u{1}_ZNKSt9exception4whatEv"]
      pub fn exception_what(this: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char;
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct atomic {
      pub _address: u8,
    }
    pub type atomic_value_type = u8;
    pub type string = [u64; 4usize];
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct char_traits {
      pub _address: u8,
    }
    pub type array_value_type = u8;
    pub type array_pointer = u8;
    pub type array_const_pointer = u8;
    pub type array_reference = u8;
    pub type array_const_reference = u8;
    pub type array_iterator = u8;
    pub type array_const_iterator = u8;
    pub type array_size_type = u64;
    pub type array_difference_type = u64;
    pub type array_reverse_iterator = u8;
    pub type array_const_reverse_iterator = u8;
    pub type array__AT_Type = u8;
  }
  pub mod __gnu_cxx {
    #[allow(unused_imports)]
    use self::super::super::root;
  }
  pub mod absl {
    #[allow(unused_imports)]
    use self::super::super::root;
    pub mod lts_20230125 {
      #[allow(unused_imports)]
      use self::super::super::super::root;
      pub mod type_traits_internal {
        #[allow(unused_imports)]
        use self::super::super::super::super::root;
        #[repr(C)]
        #[repr(align(1))]
        pub struct SingleMemberUnion<T> {
          pub t: root::__BindgenUnionField<T>,
          pub bindgen_union_field: [u8; 0usize],
          pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct IsTriviallyMoveConstructibleObject {
          pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct IsTriviallyCopyConstructibleObject {
          pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct IsTriviallyMoveAssignableReference {
          pub _base: root::std::false_type,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct VoidTImpl {
          pub _address: u8,
        }
        pub type VoidTImpl_type = ::std::os::raw::c_void;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_detected_impl {
          pub _address: u8,
        }
        pub type is_detected_impl_type = root::std::false_type;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_detected {
          pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_detected_convertible_impl {
          pub _address: u8,
        }
        pub type is_detected_convertible_impl_type = root::std::false_type;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_detected_convertible {
          pub _address: u8,
        }
        pub type IsCopyAssignableImpl<T> = T;
        pub type IsMoveAssignableImpl<T> = T;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_trivially_copyable {
          pub _address: u8,
        }
        pub type result_of = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct IsHashable {
          pub _base: root::std::false_type,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AssertHashEnabledHelper {
          pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AssertHashEnabledHelper_NAT {
          pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_AssertHashEnabledHelper_NAT() {
          assert_eq!(
            ::std::mem::size_of::<AssertHashEnabledHelper_NAT>(),
            1usize,
            concat!("Size of: ", stringify!(AssertHashEnabledHelper_NAT))
          );
          assert_eq!(
            ::std::mem::align_of::<AssertHashEnabledHelper_NAT>(),
            1usize,
            concat!("Alignment of ", stringify!(AssertHashEnabledHelper_NAT))
          );
        }
        #[test]
        fn bindgen_test_layout_AssertHashEnabledHelper() {
          assert_eq!(
            ::std::mem::size_of::<AssertHashEnabledHelper>(),
            1usize,
            concat!("Size of: ", stringify!(AssertHashEnabledHelper))
          );
          assert_eq!(
            ::std::mem::align_of::<AssertHashEnabledHelper>(),
            1usize,
            concat!("Alignment of ", stringify!(AssertHashEnabledHelper))
          );
        }
      }
      #[repr(C)]
      #[derive(Debug, Copy, Clone)]
      pub struct is_copy_assignable {
        pub _address: u8,
      }
      #[repr(C)]
      #[derive(Debug, Copy, Clone)]
      pub struct is_move_assignable {
        pub _address: u8,
      }
      pub type void_t = root::absl::lts_20230125::type_traits_internal::VoidTImpl;
      #[repr(C)]
      #[derive(Debug, Copy, Clone)]
      pub struct conjunction {
        pub _base: root::std::true_type,
      }
      #[repr(C)]
      #[derive(Debug, Copy, Clone)]
      pub struct disjunction {
        pub _base: root::std::false_type,
      }
      #[repr(C)]
      #[derive(Debug, Copy, Clone)]
      pub struct negation {
        pub _address: u8,
      }
      #[repr(C)]
      #[derive(Debug, Copy, Clone)]
      pub struct is_function {
        pub _address: u8,
      }
      #[repr(C)]
      #[derive(Debug, Copy, Clone)]
      pub struct is_trivially_destructible {
        pub _address: u8,
      }
      #[repr(C)]
      #[derive(Debug, Copy, Clone)]
      pub struct is_trivially_default_constructible {
        pub _address: u8,
      }
      #[repr(C)]
      #[derive(Debug, Copy, Clone)]
      pub struct is_trivially_move_constructible {
        pub _address: u8,
      }
      #[repr(C)]
      #[derive(Debug, Copy, Clone)]
      pub struct is_trivially_copy_constructible {
        pub _address: u8,
      }
      #[repr(C)]
      #[derive(Debug, Copy, Clone)]
      pub struct is_trivially_move_assignable {
        pub _address: u8,
      }
      #[repr(C)]
      #[derive(Debug, Copy, Clone)]
      pub struct is_trivially_copy_assignable {
        pub _address: u8,
      }
      #[repr(C)]
      #[derive(Debug, Copy, Clone)]
      pub struct remove_cvref {
        pub _address: u8,
      }
      pub type remove_cvref_type = u8;
      pub type remove_cvref_t = root::absl::lts_20230125::remove_cvref;
      pub type remove_cv_t = u8;
      pub type remove_const_t = u8;
      pub type remove_volatile_t = u8;
      pub type add_cv_t = u8;
      pub type add_const_t = u8;
      pub type add_volatile_t = u8;
      pub type remove_reference_t = u8;
      pub type add_lvalue_reference_t = u8;
      pub type add_rvalue_reference_t = u8;
      pub type remove_pointer_t = u8;
      pub type add_pointer_t = u8;
      pub type make_signed_t = u8;
      pub type make_unsigned_t = u8;
      pub type remove_extent_t = u8;
      pub type remove_all_extents_t = u8;
      pub type aligned_storage_t = u8;
      pub type decay_t = u8;
      pub type enable_if_t = u8;
      pub type conditional_t = u8;
      pub type common_type_t = u8;
      pub type underlying_type_t = u8;
      pub type result_of_t = root::absl::lts_20230125::type_traits_internal::result_of;
      pub mod swap_internal {
        #[allow(unused_imports)]
        use self::super::super::super::super::root;
        extern "C" {
          #[link_name = "\u{1}_ZN4absl12lts_2023012513swap_internal4swapEv"]
          pub fn swap();
        }
        pub type IsSwappableImpl<T> = T;
        pub type IsNothrowSwappableImpl = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct IsSwappable {
          pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct IsNothrowSwappable {
          pub _address: u8,
        }
        pub type StdSwapIsUnconstrained = root::absl::lts_20230125::swap_internal::IsSwappable;
      }
      #[repr(C)]
      #[derive(Debug, Copy, Clone)]
      pub struct is_trivially_relocatable {
        pub _address: u8,
      }
      pub mod base_internal {
        #[allow(unused_imports)]
        use self::super::super::super::super::root;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct StrippedAccept {
          pub _address: u8,
        }
        #[repr(C)]
        pub struct StrippedAccept_Accept {
          pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct MemFunAndRef {
          pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct MemFunAndRef_AcceptImpl {
          pub _base: root::std::false_type,
        }
        #[test]
        fn bindgen_test_layout_MemFunAndRef() {
          assert_eq!(
            ::std::mem::size_of::<MemFunAndRef>(),
            1usize,
            concat!("Size of: ", stringify!(MemFunAndRef))
          );
          assert_eq!(
            ::std::mem::align_of::<MemFunAndRef>(),
            1usize,
            concat!("Alignment of ", stringify!(MemFunAndRef))
          );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct MemFunAndPtr {
          pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct MemFunAndPtr_AcceptImpl {
          pub _base: root::std::false_type,
        }
        #[test]
        fn bindgen_test_layout_MemFunAndPtr() {
          assert_eq!(
            ::std::mem::size_of::<MemFunAndPtr>(),
            1usize,
            concat!("Size of: ", stringify!(MemFunAndPtr))
          );
          assert_eq!(
            ::std::mem::align_of::<MemFunAndPtr>(),
            1usize,
            concat!("Alignment of ", stringify!(MemFunAndPtr))
          );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct DataMemAndRef {
          pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct DataMemAndRef_AcceptImpl {
          pub _base: root::std::false_type,
        }
        #[test]
        fn bindgen_test_layout_DataMemAndRef() {
          assert_eq!(
            ::std::mem::size_of::<DataMemAndRef>(),
            1usize,
            concat!("Size of: ", stringify!(DataMemAndRef))
          );
          assert_eq!(
            ::std::mem::align_of::<DataMemAndRef>(),
            1usize,
            concat!("Alignment of ", stringify!(DataMemAndRef))
          );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct DataMemAndPtr {
          pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct DataMemAndPtr_AcceptImpl {
          pub _base: root::std::false_type,
        }
        #[test]
        fn bindgen_test_layout_DataMemAndPtr() {
          assert_eq!(
            ::std::mem::size_of::<DataMemAndPtr>(),
            1usize,
            concat!("Size of: ", stringify!(DataMemAndPtr))
          );
          assert_eq!(
            ::std::mem::align_of::<DataMemAndPtr>(),
            1usize,
            concat!("Alignment of ", stringify!(DataMemAndPtr))
          );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Callable {
          pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_Callable() {
          assert_eq!(
            ::std::mem::size_of::<Callable>(),
            1usize,
            concat!("Size of: ", stringify!(Callable))
          );
          assert_eq!(
            ::std::mem::align_of::<Callable>(),
            1usize,
            concat!("Alignment of ", stringify!(Callable))
          );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Invoker {
          pub _address: u8,
        }
        pub type Invoker_type = u8;
        pub type invoke_result_t = root::absl::lts_20230125::base_internal::Invoker;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct IsInvocableRImpl {
          pub _base: root::std::false_type,
        }
        pub type is_invocable_r = root::absl::lts_20230125::base_internal::IsInvocableRImpl;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AtomicHook {
          pub _address: u8,
        }
        pub const SchedulingMode_SCHEDULE_KERNEL_ONLY:
          root::absl::lts_20230125::base_internal::SchedulingMode = 0;
        pub const SchedulingMode_SCHEDULE_COOPERATIVE_AND_KERNEL:
          root::absl::lts_20230125::base_internal::SchedulingMode = 1;
        pub type SchedulingMode = ::std::os::raw::c_uint;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SpinLock {
          _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SchedulingGuard {
          pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct SchedulingGuard_ScopedDisable {
          pub disabled: bool,
        }
        #[test]
        fn bindgen_test_layout_SchedulingGuard_ScopedDisable() {
          const UNINIT: ::std::mem::MaybeUninit<SchedulingGuard_ScopedDisable> =
            ::std::mem::MaybeUninit::uninit();
          let ptr = UNINIT.as_ptr();
          assert_eq!(
            ::std::mem::size_of::<SchedulingGuard_ScopedDisable>(),
            1usize,
            concat!("Size of: ", stringify!(SchedulingGuard_ScopedDisable))
          );
          assert_eq!(
            ::std::mem::align_of::<SchedulingGuard_ScopedDisable>(),
            1usize,
            concat!("Alignment of ", stringify!(SchedulingGuard_ScopedDisable))
          );
          assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).disabled) as usize - ptr as usize },
            0usize,
            concat!(
              "Offset of field: ",
              stringify!(SchedulingGuard_ScopedDisable),
              "::",
              stringify!(disabled)
            )
          );
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct SchedulingGuard_ScopedEnable {
          pub scheduling_disabled_depth_: ::std::os::raw::c_int,
        }
        #[test]
        fn bindgen_test_layout_SchedulingGuard_ScopedEnable() {
          const UNINIT: ::std::mem::MaybeUninit<SchedulingGuard_ScopedEnable> =
            ::std::mem::MaybeUninit::uninit();
          let ptr = UNINIT.as_ptr();
          assert_eq!(
            ::std::mem::size_of::<SchedulingGuard_ScopedEnable>(),
            4usize,
            concat!("Size of: ", stringify!(SchedulingGuard_ScopedEnable))
          );
          assert_eq!(
            ::std::mem::align_of::<SchedulingGuard_ScopedEnable>(),
            4usize,
            concat!("Alignment of ", stringify!(SchedulingGuard_ScopedEnable))
          );
          assert_eq!(
            unsafe {
              ::std::ptr::addr_of!((*ptr).scheduling_disabled_depth_) as usize - ptr as usize
            },
            0usize,
            concat!(
              "Offset of field: ",
              stringify!(SchedulingGuard_ScopedEnable),
              "::",
              stringify!(scheduling_disabled_depth_)
            )
          );
        }
        #[test]
        fn bindgen_test_layout_SchedulingGuard() {
          assert_eq!(
            ::std::mem::size_of::<SchedulingGuard>(),
            1usize,
            concat!("Size of: ", stringify!(SchedulingGuard))
          );
          assert_eq!(
            ::std::mem::align_of::<SchedulingGuard>(),
            1usize,
            concat!("Alignment of ", stringify!(SchedulingGuard))
          );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SpinLockWaitTransition {
          pub from: u32,
          pub to: u32,
          pub done: bool,
        }
        #[test]
        fn bindgen_test_layout_SpinLockWaitTransition() {
          const UNINIT: ::std::mem::MaybeUninit<SpinLockWaitTransition> =
            ::std::mem::MaybeUninit::uninit();
          let ptr = UNINIT.as_ptr();
          assert_eq!(
            ::std::mem::size_of::<SpinLockWaitTransition>(),
            12usize,
            concat!("Size of: ", stringify!(SpinLockWaitTransition))
          );
          assert_eq!(
            ::std::mem::align_of::<SpinLockWaitTransition>(),
            4usize,
            concat!("Alignment of ", stringify!(SpinLockWaitTransition))
          );
          assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).from) as usize - ptr as usize },
            0usize,
            concat!(
              "Offset of field: ",
              stringify!(SpinLockWaitTransition),
              "::",
              stringify!(from)
            )
          );
          assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).to) as usize - ptr as usize },
            4usize,
            concat!(
              "Offset of field: ",
              stringify!(SpinLockWaitTransition),
              "::",
              stringify!(to)
            )
          );
          assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).done) as usize - ptr as usize },
            8usize,
            concat!(
              "Offset of field: ",
              stringify!(SpinLockWaitTransition),
              "::",
              stringify!(done)
            )
          );
        }
        extern "C" {
          #[link_name = "\u{1}_ZN4absl12lts_2023012513base_internal12SpinLockWaitEPSt6atomicIjEiPKNS1_22SpinLockWaitTransitionENS1_14SchedulingModeE"]
          pub fn SpinLockWait(
            w: *mut u32,
            n: ::std::os::raw::c_int,
            trans: *const root::absl::lts_20230125::base_internal::SpinLockWaitTransition,
            scheduling_mode: root::absl::lts_20230125::base_internal::SchedulingMode,
          ) -> u32;
        }
        extern "C" {
          #[link_name = "\u{1}_ZN4absl12lts_2023012513base_internal24SpinLockSuggestedDelayNSEi"]
          pub fn SpinLockSuggestedDelayNS(loop_: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct SchedulingHelper {
          pub mode_: root::absl::lts_20230125::base_internal::SchedulingMode,
          pub guard_result_: bool,
        }
        #[test]
        fn bindgen_test_layout_SchedulingHelper() {
          const UNINIT: ::std::mem::MaybeUninit<SchedulingHelper> =
            ::std::mem::MaybeUninit::uninit();
          let ptr = UNINIT.as_ptr();
          assert_eq!(
            ::std::mem::size_of::<SchedulingHelper>(),
            8usize,
            concat!("Size of: ", stringify!(SchedulingHelper))
          );
          assert_eq!(
            ::std::mem::align_of::<SchedulingHelper>(),
            4usize,
            concat!("Alignment of ", stringify!(SchedulingHelper))
          );
          assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).mode_) as usize - ptr as usize },
            0usize,
            concat!(
              "Offset of field: ",
              stringify!(SchedulingHelper),
              "::",
              stringify!(mode_)
            )
          );
          assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).guard_result_) as usize - ptr as usize },
            4usize,
            concat!(
              "Offset of field: ",
              stringify!(SchedulingHelper),
              "::",
              stringify!(guard_result_)
            )
          );
        }
        pub const base_internal_kOnceInit: root::absl::lts_20230125::base_internal::_bindgen_ty_1 =
          0;
        pub const base_internal_kOnceRunning:
          root::absl::lts_20230125::base_internal::_bindgen_ty_1 = 1707250555;
        pub const base_internal_kOnceWaiter:
          root::absl::lts_20230125::base_internal::_bindgen_ty_1 = 94570706;
        pub const base_internal_kOnceDone: root::absl::lts_20230125::base_internal::_bindgen_ty_1 =
          221;
        pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
        extern "C" {
          #[link_name = "\u{1}_ZN4absl12lts_2023012513base_internal18ThrowStdLogicErrorERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
          pub fn ThrowStdLogicError(what_arg: *const root::std::string);
        }
        extern "C" {
          #[link_name = "\u{1}_ZN4absl12lts_2023012513base_internal18ThrowStdLogicErrorEPKc"]
          pub fn ThrowStdLogicError1(what_arg: *const ::std::os::raw::c_char);
        }
        extern "C" {
          #[link_name = "\u{1}_ZN4absl12lts_2023012513base_internal23ThrowStdInvalidArgumentERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
          pub fn ThrowStdInvalidArgument(what_arg: *const root::std::string);
        }
        extern "C" {
          #[link_name = "\u{1}_ZN4absl12lts_2023012513base_internal23ThrowStdInvalidArgumentEPKc"]
          pub fn ThrowStdInvalidArgument1(what_arg: *const ::std::os::raw::c_char);
        }
        extern "C" {
          #[link_name = "\u{1}_ZN4absl12lts_2023012513base_internal19ThrowStdDomainErrorERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
          pub fn ThrowStdDomainError(what_arg: *const root::std::string);
        }
        extern "C" {
          #[link_name = "\u{1}_ZN4absl12lts_2023012513base_internal19ThrowStdDomainErrorEPKc"]
          pub fn ThrowStdDomainError1(what_arg: *const ::std::os::raw::c_char);
        }
        extern "C" {
          #[link_name = "\u{1}_ZN4absl12lts_2023012513base_internal19ThrowStdLengthErrorERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
          pub fn ThrowStdLengthError(what_arg: *const root::std::string);
        }
        extern "C" {
          #[link_name = "\u{1}_ZN4absl12lts_2023012513base_internal19ThrowStdLengthErrorEPKc"]
          pub fn ThrowStdLengthError1(what_arg: *const ::std::os::raw::c_char);
        }
        extern "C" {
          #[link_name = "\u{1}_ZN4absl12lts_2023012513base_internal18ThrowStdOutOfRangeERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
          pub fn ThrowStdOutOfRange(what_arg: *const root::std::string);
        }
        extern "C" {
          #[link_name = "\u{1}_ZN4absl12lts_2023012513base_internal18ThrowStdOutOfRangeEPKc"]
          pub fn ThrowStdOutOfRange1(what_arg: *const ::std::os::raw::c_char);
        }
        extern "C" {
          #[link_name = "\u{1}_ZN4absl12lts_2023012513base_internal20ThrowStdRuntimeErrorERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
          pub fn ThrowStdRuntimeError(what_arg: *const root::std::string);
        }
        extern "C" {
          #[link_name = "\u{1}_ZN4absl12lts_2023012513base_internal20ThrowStdRuntimeErrorEPKc"]
          pub fn ThrowStdRuntimeError1(what_arg: *const ::std::os::raw::c_char);
        }
        extern "C" {
          #[link_name = "\u{1}_ZN4absl12lts_2023012513base_internal18ThrowStdRangeErrorERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
          pub fn ThrowStdRangeError(what_arg: *const root::std::string);
        }
        extern "C" {
          #[link_name = "\u{1}_ZN4absl12lts_2023012513base_internal18ThrowStdRangeErrorEPKc"]
          pub fn ThrowStdRangeError1(what_arg: *const ::std::os::raw::c_char);
        }
        extern "C" {
          #[link_name = "\u{1}_ZN4absl12lts_2023012513base_internal21ThrowStdOverflowErrorERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
          pub fn ThrowStdOverflowError(what_arg: *const root::std::string);
        }
        extern "C" {
          #[link_name = "\u{1}_ZN4absl12lts_2023012513base_internal21ThrowStdOverflowErrorEPKc"]
          pub fn ThrowStdOverflowError1(what_arg: *const ::std::os::raw::c_char);
        }
        extern "C" {
          #[link_name = "\u{1}_ZN4absl12lts_2023012513base_internal22ThrowStdUnderflowErrorERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
          pub fn ThrowStdUnderflowError(what_arg: *const root::std::string);
        }
        extern "C" {
          #[link_name = "\u{1}_ZN4absl12lts_2023012513base_internal22ThrowStdUnderflowErrorEPKc"]
          pub fn ThrowStdUnderflowError1(what_arg: *const ::std::os::raw::c_char);
        }
        extern "C" {
          #[link_name = "\u{1}_ZN4absl12lts_2023012513base_internal23ThrowStdBadFunctionCallEv"]
          pub fn ThrowStdBadFunctionCall();
        }
        extern "C" {
          #[link_name = "\u{1}_ZN4absl12lts_2023012513base_internal16ThrowStdBadAllocEv"]
          pub fn ThrowStdBadAlloc();
        }
      }
      pub const LogSeverity_kInfo: root::absl::lts_20230125::LogSeverity = 0;
      pub const LogSeverity_kWarning: root::absl::lts_20230125::LogSeverity = 1;
      pub const LogSeverity_kError: root::absl::lts_20230125::LogSeverity = 2;
      pub const LogSeverity_kFatal: root::absl::lts_20230125::LogSeverity = 3;
      pub type LogSeverity = ::std::os::raw::c_int;
      pub const LogSeverityAtLeast_kInfo: root::absl::lts_20230125::LogSeverityAtLeast = 0;
      pub const LogSeverityAtLeast_kWarning: root::absl::lts_20230125::LogSeverityAtLeast = 1;
      pub const LogSeverityAtLeast_kError: root::absl::lts_20230125::LogSeverityAtLeast = 2;
      pub const LogSeverityAtLeast_kFatal: root::absl::lts_20230125::LogSeverityAtLeast = 3;
      pub const LogSeverityAtLeast_kInfinity: root::absl::lts_20230125::LogSeverityAtLeast = 1000;
      pub type LogSeverityAtLeast = ::std::os::raw::c_int;
      pub const LogSeverityAtMost_kNegativeInfinity: root::absl::lts_20230125::LogSeverityAtMost =
        -1000;
      pub const LogSeverityAtMost_kInfo: root::absl::lts_20230125::LogSeverityAtMost = 0;
      pub const LogSeverityAtMost_kWarning: root::absl::lts_20230125::LogSeverityAtMost = 1;
      pub const LogSeverityAtMost_kError: root::absl::lts_20230125::LogSeverityAtMost = 2;
      pub const LogSeverityAtMost_kFatal: root::absl::lts_20230125::LogSeverityAtMost = 3;
      pub type LogSeverityAtMost = ::std::os::raw::c_int;
      pub mod raw_log_internal {
        #[allow(unused_imports)]
        use self::super::super::super::super::root;
        extern "C" {
          #[link_name = "\u{1}_ZN4absl12lts_2023012516raw_log_internal6RawLogENS0_11LogSeverityEPKciS4_z"]
          pub fn RawLog(
            severity: root::absl::lts_20230125::LogSeverity,
            file: *const ::std::os::raw::c_char,
            line: ::std::os::raw::c_int,
            format: *const ::std::os::raw::c_char,
            ...
          );
        }
        extern "C" {
          #[link_name = "\u{1}_ZN4absl12lts_2023012516raw_log_internal28AsyncSignalSafeWriteToStderrEPKcm"]
          pub fn AsyncSignalSafeWriteToStderr(s: *const ::std::os::raw::c_char, len: usize);
        }
        extern "C" {
          #[link_name = "\u{1}_ZN4absl12lts_2023012516raw_log_internal24RawLoggingFullySupportedEv"]
          pub fn RawLoggingFullySupported() -> bool;
        }
        pub type LogFilterAndPrefixHook = ::std::option::Option<
          unsafe extern "C" fn(
            severity: root::absl::lts_20230125::LogSeverity,
            file: *const ::std::os::raw::c_char,
            line: ::std::os::raw::c_int,
            buf: *mut *mut ::std::os::raw::c_char,
            buf_size: *mut ::std::os::raw::c_int,
          ) -> bool,
        >;
        pub type AbortHook = ::std::option::Option<
          unsafe extern "C" fn(
            file: *const ::std::os::raw::c_char,
            line: ::std::os::raw::c_int,
            buf_start: *const ::std::os::raw::c_char,
            prefix_end: *const ::std::os::raw::c_char,
            buf_end: *const ::std::os::raw::c_char,
          ),
        >;
        pub type InternalLogFunction = ::std::option::Option<
          unsafe extern "C" fn(
            severity: root::absl::lts_20230125::LogSeverity,
            file: *const ::std::os::raw::c_char,
            line: ::std::os::raw::c_int,
            message: *const root::std::string,
          ),
        >;
        extern "C" {
          #[link_name = "\u{1}_ZN4absl12lts_2023012516raw_log_internal21internal_log_functionB5cxx11E"]
          pub static mut internal_log_function: root::absl::lts_20230125::base_internal::AtomicHook;
        }
        extern "C" {
          #[link_name = "\u{1}_ZN4absl12lts_2023012516raw_log_internal30RegisterLogFilterAndPrefixHookEPFbNS0_11LogSeverityEPKciPPcPiE"]
          pub fn RegisterLogFilterAndPrefixHook(
            func: root::absl::lts_20230125::raw_log_internal::LogFilterAndPrefixHook,
          );
        }
        extern "C" {
          #[link_name = "\u{1}_ZN4absl12lts_2023012516raw_log_internal17RegisterAbortHookEPFvPKciS3_S3_S3_E"]
          pub fn RegisterAbortHook(func: root::absl::lts_20230125::raw_log_internal::AbortHook);
        }
        extern "C" {
          #[link_name = "\u{1}_ZN4absl12lts_2023012516raw_log_internal27RegisterInternalLogFunctionEPFvNS0_11LogSeverityEPKciRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEE"]
          pub fn RegisterInternalLogFunction(
            func: root::absl::lts_20230125::raw_log_internal::InternalLogFunction,
          );
        }
      }
      #[repr(C)]
      #[derive(Debug, Copy, Clone)]
      pub struct CondVar {
        _unused: [u8; 0],
      }
      #[repr(C)]
      #[derive(Debug, Copy, Clone)]
      pub struct Mutex {
        _unused: [u8; 0],
      }
      pub mod synchronization_internal {
        #[allow(unused_imports)]
        use self::super::super::super::super::root;
        extern "C" {
          #[link_name = "\u{1}_ZN4absl12lts_2023012524synchronization_internal10MutexDelayEii"]
          pub fn MutexDelay(c: i32, mode: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
        }
      }
      #[repr(C)]
      #[derive(Debug)]
      pub struct once_flag {
        pub control_: u32,
      }
      #[test]
      fn bindgen_test_layout_once_flag() {
        const UNINIT: ::std::mem::MaybeUninit<once_flag> = ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
          ::std::mem::size_of::<once_flag>(),
          4usize,
          concat!("Size of: ", stringify!(once_flag))
        );
        assert_eq!(
          ::std::mem::align_of::<once_flag>(),
          4usize,
          concat!("Alignment of ", stringify!(once_flag))
        );
        assert_eq!(
          unsafe { ::std::ptr::addr_of!((*ptr).control_) as usize - ptr as usize },
          0usize,
          concat!(
            "Offset of field: ",
            stringify!(once_flag),
            "::",
            stringify!(control_)
          )
        );
      }
      #[repr(C)]
      #[derive(Debug, Copy, Clone)]
      pub struct string_view {
        pub ptr_: *const ::std::os::raw::c_char,
        pub length_: root::absl::lts_20230125::string_view_size_type,
      }
      pub type string_view_traits_type = u8;
      pub type string_view_value_type = ::std::os::raw::c_char;
      pub type string_view_pointer = *mut ::std::os::raw::c_char;
      pub type string_view_const_pointer = *const ::std::os::raw::c_char;
      pub type string_view_reference = *mut ::std::os::raw::c_char;
      pub type string_view_const_reference = *const ::std::os::raw::c_char;
      pub type string_view_const_iterator = *const ::std::os::raw::c_char;
      pub type string_view_iterator = root::absl::lts_20230125::string_view_const_iterator;
      pub type string_view_const_reverse_iterator = u64;
      pub type string_view_reverse_iterator =
        root::absl::lts_20230125::string_view_const_reverse_iterator;
      pub type string_view_size_type = usize;
      pub type string_view_difference_type = isize;
      #[repr(C)]
      #[derive(Debug, Copy, Clone)]
      pub struct string_view_SkipCheckLengthTag {
        pub _address: u8,
      }
      #[test]
      fn bindgen_test_layout_string_view_SkipCheckLengthTag() {
        assert_eq!(
          ::std::mem::size_of::<string_view_SkipCheckLengthTag>(),
          1usize,
          concat!("Size of: ", stringify!(string_view_SkipCheckLengthTag))
        );
        assert_eq!(
          ::std::mem::align_of::<string_view_SkipCheckLengthTag>(),
          1usize,
          concat!("Alignment of ", stringify!(string_view_SkipCheckLengthTag))
        );
      }
      extern "C" {
        #[link_name = "\u{1}_ZN4absl12lts_2023012511string_view4nposE"]
        pub static string_view_npos: root::absl::lts_20230125::string_view_size_type;
      }
      pub const string_view_kMaxSize: root::absl::lts_20230125::string_view_size_type =
        9223372036854775807;
      #[test]
      fn bindgen_test_layout_string_view() {
        const UNINIT: ::std::mem::MaybeUninit<string_view> = ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
          ::std::mem::size_of::<string_view>(),
          16usize,
          concat!("Size of: ", stringify!(string_view))
        );
        assert_eq!(
          ::std::mem::align_of::<string_view>(),
          8usize,
          concat!("Alignment of ", stringify!(string_view))
        );
        assert_eq!(
          unsafe { ::std::ptr::addr_of!((*ptr).ptr_) as usize - ptr as usize },
          0usize,
          concat!(
            "Offset of field: ",
            stringify!(string_view),
            "::",
            stringify!(ptr_)
          )
        );
        assert_eq!(
          unsafe { ::std::ptr::addr_of!((*ptr).length_) as usize - ptr as usize },
          8usize,
          concat!(
            "Offset of field: ",
            stringify!(string_view),
            "::",
            stringify!(length_)
          )
        );
      }
      extern "C" {
        #[link_name = "\u{1}_ZNK4absl12lts_2023012511string_view4findES1_m"]
        pub fn string_view_find(
          this: *const root::absl::lts_20230125::string_view,
          s: root::absl::lts_20230125::string_view,
          pos: root::absl::lts_20230125::string_view_size_type,
        ) -> root::absl::lts_20230125::string_view_size_type;
      }
      extern "C" {
        #[link_name = "\u{1}_ZNK4absl12lts_2023012511string_view4findEcm"]
        pub fn string_view_find1(
          this: *const root::absl::lts_20230125::string_view,
          c: ::std::os::raw::c_char,
          pos: root::absl::lts_20230125::string_view_size_type,
        ) -> root::absl::lts_20230125::string_view_size_type;
      }
      extern "C" {
        #[link_name = "\u{1}_ZNK4absl12lts_2023012511string_view5rfindES1_m"]
        pub fn string_view_rfind(
          this: *const root::absl::lts_20230125::string_view,
          s: root::absl::lts_20230125::string_view,
          pos: root::absl::lts_20230125::string_view_size_type,
        ) -> root::absl::lts_20230125::string_view_size_type;
      }
      extern "C" {
        #[link_name = "\u{1}_ZNK4absl12lts_2023012511string_view5rfindEcm"]
        pub fn string_view_rfind1(
          this: *const root::absl::lts_20230125::string_view,
          c: ::std::os::raw::c_char,
          pos: root::absl::lts_20230125::string_view_size_type,
        ) -> root::absl::lts_20230125::string_view_size_type;
      }
      extern "C" {
        #[link_name = "\u{1}_ZNK4absl12lts_2023012511string_view13find_first_ofES1_m"]
        pub fn string_view_find_first_of(
          this: *const root::absl::lts_20230125::string_view,
          s: root::absl::lts_20230125::string_view,
          pos: root::absl::lts_20230125::string_view_size_type,
        ) -> root::absl::lts_20230125::string_view_size_type;
      }
      extern "C" {
        #[link_name = "\u{1}_ZNK4absl12lts_2023012511string_view12find_last_ofES1_m"]
        pub fn string_view_find_last_of(
          this: *const root::absl::lts_20230125::string_view,
          s: root::absl::lts_20230125::string_view,
          pos: root::absl::lts_20230125::string_view_size_type,
        ) -> root::absl::lts_20230125::string_view_size_type;
      }
      extern "C" {
        #[link_name = "\u{1}_ZNK4absl12lts_2023012511string_view17find_first_not_ofES1_m"]
        pub fn string_view_find_first_not_of(
          this: *const root::absl::lts_20230125::string_view,
          s: root::absl::lts_20230125::string_view,
          pos: root::absl::lts_20230125::string_view_size_type,
        ) -> root::absl::lts_20230125::string_view_size_type;
      }
      extern "C" {
        #[link_name = "\u{1}_ZNK4absl12lts_2023012511string_view17find_first_not_ofEcm"]
        pub fn string_view_find_first_not_of1(
          this: *const root::absl::lts_20230125::string_view,
          c: ::std::os::raw::c_char,
          pos: root::absl::lts_20230125::string_view_size_type,
        ) -> root::absl::lts_20230125::string_view_size_type;
      }
      extern "C" {
        #[link_name = "\u{1}_ZNK4absl12lts_2023012511string_view16find_last_not_ofES1_m"]
        pub fn string_view_find_last_not_of(
          this: *const root::absl::lts_20230125::string_view,
          s: root::absl::lts_20230125::string_view,
          pos: root::absl::lts_20230125::string_view_size_type,
        ) -> root::absl::lts_20230125::string_view_size_type;
      }
      extern "C" {
        #[link_name = "\u{1}_ZNK4absl12lts_2023012511string_view16find_last_not_ofEcm"]
        pub fn string_view_find_last_not_of1(
          this: *const root::absl::lts_20230125::string_view,
          c: ::std::os::raw::c_char,
          pos: root::absl::lts_20230125::string_view_size_type,
        ) -> root::absl::lts_20230125::string_view_size_type;
      }
      impl string_view {
        #[inline]
        pub unsafe fn find(
          &self,
          s: root::absl::lts_20230125::string_view,
          pos: root::absl::lts_20230125::string_view_size_type,
        ) -> root::absl::lts_20230125::string_view_size_type {
          string_view_find(self, s, pos)
        }

        #[inline]
        pub unsafe fn find1(
          &self,
          c: ::std::os::raw::c_char,
          pos: root::absl::lts_20230125::string_view_size_type,
        ) -> root::absl::lts_20230125::string_view_size_type {
          string_view_find1(self, c, pos)
        }

        #[inline]
        pub unsafe fn rfind(
          &self,
          s: root::absl::lts_20230125::string_view,
          pos: root::absl::lts_20230125::string_view_size_type,
        ) -> root::absl::lts_20230125::string_view_size_type {
          string_view_rfind(self, s, pos)
        }

        #[inline]
        pub unsafe fn rfind1(
          &self,
          c: ::std::os::raw::c_char,
          pos: root::absl::lts_20230125::string_view_size_type,
        ) -> root::absl::lts_20230125::string_view_size_type {
          string_view_rfind1(self, c, pos)
        }

        #[inline]
        pub unsafe fn find_first_of(
          &self,
          s: root::absl::lts_20230125::string_view,
          pos: root::absl::lts_20230125::string_view_size_type,
        ) -> root::absl::lts_20230125::string_view_size_type {
          string_view_find_first_of(self, s, pos)
        }

        #[inline]
        pub unsafe fn find_last_of(
          &self,
          s: root::absl::lts_20230125::string_view,
          pos: root::absl::lts_20230125::string_view_size_type,
        ) -> root::absl::lts_20230125::string_view_size_type {
          string_view_find_last_of(self, s, pos)
        }

        #[inline]
        pub unsafe fn find_first_not_of(
          &self,
          s: root::absl::lts_20230125::string_view,
          pos: root::absl::lts_20230125::string_view_size_type,
        ) -> root::absl::lts_20230125::string_view_size_type {
          string_view_find_first_not_of(self, s, pos)
        }

        #[inline]
        pub unsafe fn find_first_not_of1(
          &self,
          c: ::std::os::raw::c_char,
          pos: root::absl::lts_20230125::string_view_size_type,
        ) -> root::absl::lts_20230125::string_view_size_type {
          string_view_find_first_not_of1(self, c, pos)
        }

        #[inline]
        pub unsafe fn find_last_not_of(
          &self,
          s: root::absl::lts_20230125::string_view,
          pos: root::absl::lts_20230125::string_view_size_type,
        ) -> root::absl::lts_20230125::string_view_size_type {
          string_view_find_last_not_of(self, s, pos)
        }

        #[inline]
        pub unsafe fn find_last_not_of1(
          &self,
          c: ::std::os::raw::c_char,
          pos: root::absl::lts_20230125::string_view_size_type,
        ) -> root::absl::lts_20230125::string_view_size_type {
          string_view_find_last_not_of1(self, c, pos)
        }
      }
      pub mod internal {
        #[allow(unused_imports)]
        use self::super::super::super::super::root;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct identity {
          pub _address: u8,
        }
        pub type identity_type<T> = T;
        pub type identity_t = root::absl::lts_20230125::internal::identity;
      }
      pub type integer_sequence_value_type<T> = T;
      pub type index_sequence = u8;
      pub mod utility_internal {
        #[allow(unused_imports)]
        use self::super::super::super::super::root;
        pub type Gen_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct InPlaceTypeTag {
          pub _address: u8,
        }
      }
      pub type make_integer_sequence = u8;
      pub type make_index_sequence = root::absl::lts_20230125::make_integer_sequence;
      pub type index_sequence_for = root::absl::lts_20230125::make_index_sequence;
      #[repr(C)]
      #[derive(Debug, Copy, Clone)]
      pub struct in_place_t {
        pub _address: u8,
      }
      #[test]
      fn bindgen_test_layout_in_place_t() {
        assert_eq!(
          ::std::mem::size_of::<in_place_t>(),
          1usize,
          concat!("Size of: ", stringify!(in_place_t))
        );
        assert_eq!(
          ::std::mem::align_of::<in_place_t>(),
          1usize,
          concat!("Alignment of ", stringify!(in_place_t))
        );
      }
      #[repr(C)]
      #[derive(Debug, Copy, Clone)]
      pub struct AbslInternalInlineVariableHolderin_place {
        pub _address: u8,
      }
      extern "C" {
        pub static kInstance: root::absl::lts_20230125::in_place_t;
      }
      extern "C" {
        #[link_name = "\u{1}_ZN4absl12lts_20230125L8in_placeE"]
        pub static mut in_place: *const root::absl::lts_20230125::in_place_t;
      }
      pub type in_place_type_t = ::std::option::Option<
        unsafe extern "C" fn(arg1: root::absl::lts_20230125::utility_internal::InPlaceTypeTag),
      >;
      pub type in_place_index_t = ::std::option::Option<unsafe extern "C" fn(arg1: u8)>;
      #[repr(C)]
      #[derive(Debug)]
      pub struct bad_optional_access {
        pub _base: root::std::exception,
      }
      #[test]
      fn bindgen_test_layout_bad_optional_access() {
        assert_eq!(
          ::std::mem::size_of::<bad_optional_access>(),
          8usize,
          concat!("Size of: ", stringify!(bad_optional_access))
        );
        assert_eq!(
          ::std::mem::align_of::<bad_optional_access>(),
          8usize,
          concat!("Alignment of ", stringify!(bad_optional_access))
        );
      }
      extern "C" {
        #[link_name = "\u{1}_ZN4absl12lts_2023012519bad_optional_accessD1Ev"]
        pub fn bad_optional_access_bad_optional_access_destructor(
          this: *mut root::absl::lts_20230125::bad_optional_access,
        );
      }
      extern "C" {
        #[link_name = "\u{1}_ZNK4absl12lts_2023012519bad_optional_access4whatEv"]
        pub fn bad_optional_access_what(
          this: *mut ::std::os::raw::c_void,
        ) -> *const ::std::os::raw::c_char;
      }
      pub mod optional_internal {
        #[allow(unused_imports)]
        use self::super::super::super::super::root;
        extern "C" {
          #[link_name = "\u{1}_ZN4absl12lts_2023012517optional_internal25throw_bad_optional_accessEv"]
          pub fn throw_bad_optional_access();
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct init_t {
          pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_init_t() {
          assert_eq!(
            ::std::mem::size_of::<init_t>(),
            1usize,
            concat!("Size of: ", stringify!(init_t))
          );
          assert_eq!(
            ::std::mem::align_of::<init_t>(),
            1usize,
            concat!("Alignment of ", stringify!(init_t))
          );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct empty_struct {
          pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_empty_struct() {
          assert_eq!(
            ::std::mem::size_of::<empty_struct>(),
            1usize,
            concat!("Size of: ", stringify!(empty_struct))
          );
          assert_eq!(
            ::std::mem::align_of::<empty_struct>(),
            1usize,
            concat!("Alignment of ", stringify!(empty_struct))
          );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct optional_data_dtor_base_dummy_type {
          pub data: *mut root::absl::lts_20230125::optional_internal::empty_struct,
        }
        #[repr(C)]
        #[repr(align(1))]
        pub struct optional_data_dtor_base__bindgen_ty_1<T> {
          pub data_: root::__BindgenUnionField<T>,
          pub dummy_: root::__BindgenUnionField<
            root::absl::lts_20230125::optional_internal::optional_data_dtor_base_dummy_type,
          >,
          pub bindgen_union_field: [u8; 0usize],
          pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct optional_data_base {
          pub _address: u8,
        }
        pub type optional_data_base_base = u8;
        pub const copy_traits_copyable: root::absl::lts_20230125::optional_internal::copy_traits =
          0;
        pub const copy_traits_movable: root::absl::lts_20230125::optional_internal::copy_traits = 1;
        pub const copy_traits_non_movable:
          root::absl::lts_20230125::optional_internal::copy_traits = 2;
        pub type copy_traits = ::std::os::raw::c_int;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ctor_copy_traits {
          pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct assign_copy_traits {
          pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_constructible_convertible_from_optional {
          pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_constructible_convertible_assignable_from_optional {
          pub _address: u8,
        }
        extern "C" {
          #[link_name = "\u{1}_ZN4absl12lts_2023012517optional_internal19convertible_to_boolEb"]
          pub fn convertible_to_bool(arg1: bool) -> bool;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct optional_hash_base {
          pub _address: u8,
        }
      }
      pub mod memory_internal {
        #[allow(unused_imports)]
        use self::super::super::super::super::root;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ExtractOr {
          pub _address: u8,
        }
        pub type ExtractOr_type<Default> = Default;
        pub type ExtractOrT = root::absl::lts_20230125::memory_internal::ExtractOr;
        pub type GetIsNothrow = [u8; 0usize];
      }
      #[repr(C)]
      #[derive(Debug, Copy, Clone)]
      pub struct allocator_is_nothrow {
        pub _address: u8,
      }
      #[repr(C)]
      #[derive(Debug, Copy, Clone)]
      pub struct default_allocator_is_nothrow {
        pub _base: root::std::false_type,
      }
      #[test]
      fn bindgen_test_layout_default_allocator_is_nothrow() {
        assert_eq!(
          ::std::mem::size_of::<default_allocator_is_nothrow>(),
          1usize,
          concat!("Size of: ", stringify!(default_allocator_is_nothrow))
        );
        assert_eq!(
          ::std::mem::align_of::<default_allocator_is_nothrow>(),
          1usize,
          concat!("Alignment of ", stringify!(default_allocator_is_nothrow))
        );
      }
      #[repr(C)]
      #[derive(Debug, Copy, Clone)]
      pub struct nullopt_t {
        pub _address: u8,
      }
      #[test]
      fn bindgen_test_layout_nullopt_t() {
        assert_eq!(
          ::std::mem::size_of::<nullopt_t>(),
          1usize,
          concat!("Size of: ", stringify!(nullopt_t))
        );
        assert_eq!(
          ::std::mem::align_of::<nullopt_t>(),
          1usize,
          concat!("Alignment of ", stringify!(nullopt_t))
        );
      }
      #[repr(C)]
      #[derive(Debug, Copy, Clone)]
      pub struct AbslInternalInlineVariableHoldernullopt {
        pub _address: u8,
      }
      extern "C" {
        #[link_name = "\u{1}_ZN4absl12lts_20230125L7nulloptE"]
        pub static mut nullopt: *const root::absl::lts_20230125::nullopt_t;
      }
      #[repr(C)]
      #[derive(Debug)]
      pub struct optional {
        pub _address: u8,
      }
      pub type optional_data_base = u8;
      pub type optional_value_type<T> = T;
    }
  }
  #[repr(C)]
  #[derive(Debug, Copy, Clone)]
  pub struct _bindgen_ty_36 {
    pub _address: u8,
  }
  #[repr(C)]
  #[derive(Debug, Copy, Clone)]
  pub struct _bindgen_ty_37 {
    pub _address: u8,
  }
  #[repr(C)]
  #[derive(Debug, Copy, Clone)]
  pub struct _bindgen_ty_38 {
    pub _address: u8,
  }
  #[repr(C)]
  #[derive(Debug, Copy, Clone)]
  pub struct _bindgen_ty_39 {
    pub _address: u8,
  }
  #[test]
  fn __bindgen_test_layout_StrippedAccept_open0_MemFunAndRef_close0_instantiation() {
    assert_eq!(
      ::std::mem::size_of::<root::absl::lts_20230125::base_internal::StrippedAccept>(),
      1usize,
      concat!(
        "Size of template specialization: ",
        stringify!(root::absl::lts_20230125::base_internal::StrippedAccept)
      )
    );
    assert_eq!(
      ::std::mem::align_of::<root::absl::lts_20230125::base_internal::StrippedAccept>(),
      1usize,
      concat!(
        "Alignment of template specialization: ",
        stringify!(root::absl::lts_20230125::base_internal::StrippedAccept)
      )
    );
  }
  #[test]
  fn __bindgen_test_layout_StrippedAccept_open0_MemFunAndPtr_close0_instantiation() {
    assert_eq!(
      ::std::mem::size_of::<root::absl::lts_20230125::base_internal::StrippedAccept>(),
      1usize,
      concat!(
        "Size of template specialization: ",
        stringify!(root::absl::lts_20230125::base_internal::StrippedAccept)
      )
    );
    assert_eq!(
      ::std::mem::align_of::<root::absl::lts_20230125::base_internal::StrippedAccept>(),
      1usize,
      concat!(
        "Alignment of template specialization: ",
        stringify!(root::absl::lts_20230125::base_internal::StrippedAccept)
      )
    );
  }
  #[test]
  fn __bindgen_test_layout_StrippedAccept_open0_DataMemAndRef_close0_instantiation() {
    assert_eq!(
      ::std::mem::size_of::<root::absl::lts_20230125::base_internal::StrippedAccept>(),
      1usize,
      concat!(
        "Size of template specialization: ",
        stringify!(root::absl::lts_20230125::base_internal::StrippedAccept)
      )
    );
    assert_eq!(
      ::std::mem::align_of::<root::absl::lts_20230125::base_internal::StrippedAccept>(),
      1usize,
      concat!(
        "Alignment of template specialization: ",
        stringify!(root::absl::lts_20230125::base_internal::StrippedAccept)
      )
    );
  }
  #[test]
  fn __bindgen_test_layout_StrippedAccept_open0_DataMemAndPtr_close0_instantiation() {
    assert_eq!(
      ::std::mem::size_of::<root::absl::lts_20230125::base_internal::StrippedAccept>(),
      1usize,
      concat!(
        "Size of template specialization: ",
        stringify!(root::absl::lts_20230125::base_internal::StrippedAccept)
      )
    );
    assert_eq!(
      ::std::mem::align_of::<root::absl::lts_20230125::base_internal::StrippedAccept>(),
      1usize,
      concat!(
        "Alignment of template specialization: ",
        stringify!(root::absl::lts_20230125::base_internal::StrippedAccept)
      )
    );
  }
}
